const questionsContainer = document.getElementById("questions-container")
const resultsContainer = document.getElementById("results-container")
const finishQuestionsButton = document.getElementById("finish-questions-button")
const resultFunction = document.getElementById("result-function")
const resultDescription = document.getElementById("result-description")
const resultFunctionCanvas = document.getElementById("result-function-canvas")
const resultFunctionContext = resultFunctionCanvas.getContext("2d")
const resultsTableBody = document.getElementById("results-table-body")
const NUM_BUTTONS_PER_QUESTION = 7
function shuffle(array) {
let m = array.length, t, i
while (m) {
i = Math.floor(Math.random() * m--)
t = array[m]
array[m] = array[i]
array[i] = t
}
return array
}
const TestResultCategories = {
Oscillation: 1,
Growth: 2,
Chaotic: 3,
Logical: 4
}
const TestResultCategoryNames = {
Chaotic: {
en: "Chaotic",
de: "Chaotisch"
},
Logical: {
en: "Logical",
de: "Logisch"
},
Oscillation: {
en: "Oscillation",
de: "Schwingung"
},
Growth: {
en: "Growth",
de: "Wachstum"
}
}
const TestQuestions = [
{
statement: {
en: "You enjoy taking risks.",
de: "Du genießt es, Risiken einzugehen."
},
effect: {
agree: { Growth: 0.7, Oscillation: -1.2 },
disagree: { Growth: -0.6, Oscillation: 1.03 }
}
},
{
statement: {
en: "You know your limits and don't push them.",
de: "Du kennst deine Grenzen und überschreitest sie nicht."
},
effect: {
agree: { Growth: -1.2 },
disagree: { Growth: 0.82 }
}
},
{
statement: {
en: "You are very organized and like to plan ahead.",
de: "Du bist sehr organisiert und planst gerne im Voraus."
},
effect: {
agree: { Chaotic: -1.3 },
disagree: { Chaotic: 1.1 }
}
},
{
statement: {
en: "When your heart disagrees with your mind, you follow your heart.",
de: "Wenn dein Herz nicht mit deinem Verstand übereinstimmt, folgst du deinem Herzen."
},
effect: {
agree: { Logical: -0.9 },
disagree: { Logical: 1.2 }
}
},
{
statement: {
en: "You are always on the move and can't sit still.",
de: "Du bist immer in Bewegung und kannst nicht stillsitzen."
},
effect: {
agree: { Oscillation: 1.4 },
disagree: { Oscillation: -1.1 }
}
},
{
statement: {
en: "You like to be the center of attention.",
de: "Du magst es, im Mittelpunkt zu stehen."
},
effect: {
agree: { Growth: 1.1 },
disagree: { Growth: -1.2 }
}
},
{
statement: {
en: "You are very emotional and always follow your feelings.",
de: "Du bist sehr emotional und folgst immer deinen Gefühlen."
},
effect: {
agree: { Logical: -1.8 },
disagree: { Logical: 1.6 }
}
},
{
statement: {
en: "You like to take things slow and steady.",
de: "Du magst es, die Dinge langsam und stetig anzugehen."
},
effect: {
agree: { Oscillation: -1, Chaotic: 0.5, Growth: -0.5 },
disagree: { Oscillation: 1, Chaotic: -0.5, Growth: 0.5 }
}
},
{
statement: {
en: "You don't like to try new things and experiment.",
de: "Du magst es nicht, neue Dinge auszuprobieren und zu experimentieren."
},
effect: {
agree: { Chaotic: -1.2, Growth: -0.59 },
disagree: { Chaotic: 1.1, Growth: 0.52 }
}
},
{
statement: {
en: "You love prime numbers.",
de: "Du liebst Primzahlen."
},
effect: {
agree: { Chaotic: 0.6, Oscillation: -0.6, Logical: 0.7 },
disagree: { Chaotic: -0.8, Oscillation: 0.45, Logical: -0.6 }
}
},
{
statement: {
en: "You love calculating derivatives.",
de: "Du liebst es, Ableitungen zu berechnen."
},
effect: {
agree: { Chaotic: -0.5, Logical: 1.2 },
disagree: { Chaotic: 0.7, Logical: -1 }
}
},
{
statement: {
en: "You have a favorite mathematical constant.",
de: "Du hast eine Lieblings mathematische Konstante."
},
effect: {
agree: { Chaotic: -0.3, Oscillation: 0.5, Logical: 1.1 },
disagree: { Chaotic: 0.6, Oscillation: -0.4, Logical: -1 }
}
},
{
statement: {
en: "Sometimes you feel like you are on a rollercoaster.",
de: "Manchmal fühlt es sich an, als wärst du auf einer Achterbahn."
},
effect: {
agree: { Oscillation: 1.2, Chaotic: -0.8 },
disagree: { Oscillation: -1.1, Chaotic: 0.7 }
}
},
{
statement: {
en: "You often find yourself asking mathematical questions in everyday life.",
de: "Du stellst dir oft mathematische Fragen im Alltag."
},
effect: {
agree: { Logical: 1.3, Chaotic: 0.51 },
disagree: { Logical: -1.2, Chaotic: -0.52 }
}
},
{
statement: {
en: "You can't prove the irrationality of sqrt(2) without asking ChatGPT.",
de: "Du kannst die Irrationalität von sqrt(2) nicht beweisen, ohne ChatGPT zu fragen."
},
effect: {
agree: { Logical: -1.4, Chaotic: 0.7 },
disagree: { Logical: 1.5, Chaotic: -0.6 }
}
},
{
statement: {
en: "Small numbers are more interesting than large numbers.",
de: "Kleine Zahlen sind interessanter als große Zahlen."
},
effect: {
agree: { Growth: -2 },
disagree: { Growth: 2.5 }
}
},
{
statement: {
en: "You have been to a recreational Maths meetup.",
de: "Du warst schon mal bei einem Recreational Maths Meetup."
},
effect: {
agree: { Chaotic: 0.8, Growth: 0.6 },
disagree: { Chaotic: -0.7, Growth: -0.5 }
}
},
{
statement: {
en: "When playing games, you never think about the optimal strategy.",
de: "Beim Spielen denkst du nie über die optimale Strategie nach."
},
effect: {
agree: { Logical: -1.3, Chaotic: 0.6 },
disagree: { Logical: 1.4, Chaotic: -0.5 }
}
},
{
statement: {
en: "You enjoy teaching abstract concepts to others.",
de: "Du erklärst anderen gerne abstrakte Konzepte."
},
effect: {
agree: { Growth: 0.9, Chaotic: 0.2 },
disagree: { Growth: -1.2, Chaotic: -0.1 }
}
},
{
statement: {
en: "You prefer working alone rather than in a group.",
de: "Du arbeitest lieber alleine als im Team."
},
effect: {
agree: { Chaotic: -0.7, Growth: 0.5, Logical: 0.6, Oscillation: -0.4 },
disagree: { Chaotic: 0.8, Growth: -0.6, Logical: -0.7, Oscillation: 0.5 }
}
}
]
const TestResults = [
{
termString: "x",
location: {
Growth: 0,
Chaotic: 0,
Logical: 0,
Oscillation: 0
},
description: {
en: "You are the identity function. You are very balanced and don't have any strong preferences. Some might say you are boring, but you are just very stable and reliable.",
de: "Du bist die Identitätsfunktion. Du bist sehr ausgewogen und hast keine starken Vorlieben. Manche könnten sagen, du bist langweilig, aber du bist einfach sehr stabil und zuverlässig."
},
},
{
termString: "sin(x)",
location: {
Growth: 0,
Chaotic: 0,
Logical: 0,
Oscillation: 1
},
description: {
en: "You are the sine function. Your life is full of ups and downs, but you always come back to the same point. Life is a rollercoaster for you, but you enjoy the ride.",
de: "Du bist die Sinusfunktion. Dein Leben ist voller Höhen und Tiefen, aber du kommst immer wieder zum gleichen Punkt zurück. Das Leben ist eine Achterbahnfahrt für dich, aber du genießt die Fahrt."
}
},
{
termString: "factorial(x)",
location: {
Growth: 1,
Chaotic: 0,
Logical: 0,
Oscillation: 0
},
description: {
en: "You are the factorial function. You are very bold and always take risks. You grow rapidly and don't fear to expand your horizons. Not everyone can keep up with you, but you are always ready to help others grow.",
de: "Du bist die Fakultätsfunktion. Du bist sehr mutig und gehst immer Risiken ein. Du wächst schnell und scheust dich nicht, deine Horizonte zu erweitern. Nicht jeder kann mit dir Schritt halten, aber du bist immer bereit, anderen beim Wachsen zu helfen."
}
},
{
termString: "tan(x)",
location: {
Growth: 0,
Chaotic: 1,
Logical: 0,
Oscillation: 0
},
description: {
en: "You are the tangent function. You are very chaotic and unpredictable. You like to take risks and don't care about the consequences. You are always looking for new challenges and adventures.",
de: "Du bist die Tangensfunktion. Du bist sehr chaotisch und unberechenbar. Du gehst gerne Risiken ein und kümmerst dich nicht um die Konsequenzen. Du suchst immer nach neuen Herausforderungen und Abenteuern."
}
},
{
termString: "e^x",
location: {
Growth: 1,
Chaotic: 0,
Logical: 1,
Oscillation: 0
},
description: {
en: "You are the exponential function. You are very logical and always follow a clear path. You grow rapidly and don't fear to expand your horizons. You are very reliable and always keep your promises. Your only enemy is the logarithm function, which tries to bring you down.",
de: "Du bist die Exponentialfunktion. Du bist sehr logisch und folgst immer einem klaren Weg. Du wächst schnell und scheust dich nicht, deine Horizonte zu erweitern. Du bist sehr zuverlässig und hältst immer deine Versprechen. Dein einziger Feind ist die Logarithmusfunktion, die versucht, dich zu Fall zu bringen."
}
},
{
termString: "pi",
location: {
Growth: 0,
Chaotic: 0,
Logical: 0,
Oscillation: -1
},
description: {
en: "You are the constant pi. You are very stable and reliable, but you don't like to take risks. People can always count on you.",
de: "Du bist die Konstante pi. Du bist sehr stabil und zuverlässig, aber du gehst keine Risiken ein. Die Leute können sich immer auf dich verlassen."
}
},
{
termString: "log(x)",
location: {
Growth: -1,
Chaotic: -1,
Logical: 0,
Oscillation: 0
},
description: {
en: "You are the logarithm function. You grow really really slowly, but are really quite useful! Friends can always count on you to help them solve their problems, even if it takes a while. Your only enemy is the exponential function, which tries to outgrow you.",
de: "Du bist die Logarithmusfunktion. Du wächst wirklich sehr langsam, aber du bist wirklich nützlich! Freunde können sich immer darauf verlassen, dass du ihnen hilfst, ihre Probleme zu lösen, auch wenn es eine Weile dauert. Dein einziger Feind ist die Exponentialfunktion, die versucht, dich zu übertreffen."
}
},
{
termString: "abs(x-1)+abs(x+1)",
location: {
Growth: 0,
Chaotic: 0,
Logical: -1,
Oscillation: 0
},
description: {
en: "You make zero sense. You are the absolute value function, but you are always at least 2 units away from zero. You're really the most illogical function here, but that makes you fun and nice.",
de: "Du machst keinen Sinn. Du bist die Absolutwertfunktion, aber du bist immer mindestens 2 Einheiten von Null entfernt. Du bist wirklich die unlogischste Funktion hier, aber das macht dich spaßig und nett."
}
},
{
termString: "sqrt(x)+sin(x)",
location: {
Growth: 0.3,
Chaotic: -0.5,
Logical: 0.5,
Oscillation: 0.7
},
description: {
en: "You are the square root function plus sine. You are very balanced and have a good mix of growth, chaos, logic, and oscillation. You are a very well-rounded person and can adapt to any situation.",
de: "Du bist die Quadratwurzelfunktion plus Sinus. Du bist sehr ausgewogen und hast eine gute Mischung aus Wachstum, Chaos, Logik und Schwingung. Du bist eine sehr vielseitige Person und kannst dich jeder Situation anpassen."
}
},
{
termString: "x^2",
location: {
Growth: 0.5,
Chaotic: 0,
Logical: 1,
Oscillation: -0.5
},
description: {
en: "You are the quadratic function. You are very bold and always take risks. You grow rapidly and don't fear to expand your horizons. You are very reliable and always keep your promises.",
de: "Du bist die quadratische Funktion. Du bist sehr mutig und gehst immer Risiken ein. Du wächst schnell und scheust dich nicht, deine Horizonte zu erweitern. Du bist sehr zuverlässig und hältst immer deine Versprechen."
}
},
{
termString: "cos(x)",
location: {
Growth: 0,
Chaotic: 0,
Logical: -1,
Oscillation: 1
},
description: {
en: "You are the cosine function. You are very stable and reliable, but you don't like to take risks. You really like your friend, the sine function, but you are always a bit behind. You are very logical and always follow a clear path.",
de: "Du bist die Kosinusfunktion. Du bist sehr stabil und zuverlässig, aber du gehst keine Risiken ein. Du magst wirklich deinen Freund, die Sinusfunktion, aber du bist immer ein bisschen hinterher. Du bist sehr logisch und folgst immer einem klaren Weg."
}
},
{
termString: "x^3",
location: {
Growth: -0.5,
Chaotic: -0.3,
Logical: 0.7,
Oscillation: 0
},
description: {
en: "You are the cubic function. You've been through a lot, but you always come out stronger. You are very logical and always follow a clear path. You are very reliable and always keep your promises.",
de: "Du bist die kubische Funktion. Du hast viel durchgemacht, aber du kommst immer stärker heraus. Du bist sehr logisch und folgst immer einem klaren Weg. Du bist sehr zuverlässig und hältst immer deine Versprechen."
}
},
{
termString: "-x",
location: {
Growth: -1,
Chaotic: -1,
Logical: 1,
Oscillation: 0
},
description: {
en: "You are the negative identity function. You are very logical but tend to be pessimistic. You always see the negative side of things and don't like to take risks. You are very reliable and always keep your promises.",
de: "Du bist die negative Identitätsfunktion. Du bist sehr logisch, neigst aber dazu, pessimistisch zu sein. Du siehst immer die negative Seite der Dinge und gehst keine Risiken ein. Du bist sehr zuverlässig und hältst immer deine Versprechen."
}
},
{
termString: "abs(x)",
location: { Growth: 0.3, Chaotic: -0.6, Logical: 0.8, Oscillation: -0.2 },
description: {
en: "You are the absolute value. No matter how life dips, you bounce back non-negative. Steady, resilient, and sensibly practical.",
de: "Du bist der Betrag. Egal, wie das Leben abfällt - du prallst nichtnegativ zurück. Beständig, widerstandsfähig und pragmatisch."
}
},
{
termString: "1/x",
location: { Growth: 0.0, Chaotic: 0.7, Logical: 0.2, Oscillation: 0.1 },
description: {
en: "You're the reciprocal. Most days are smooth, but you have dramatic asymptotes. People learn to respect your boundaries.",
de: "Du bist der Kehrwert. Meistens läuft es glatt, doch du hast dramatische Asymptoten. Man lernt, deine Grenzen zu respektieren."
}
},
{
termString: "sin(x)/x",
location: { Growth: 0.1, Chaotic: -0.2, Logical: 0.4, Oscillation: 0.8 },
description: {
en: "You're sinc. You oscillate, but your waves settle. Big energy, then measured ripples—refined enthusiasm. Engineers love you.",
de: "Du bist sinc. Du schwingst, aber die Wellen beruhigen sich. Erst viel Energie, dann maßvolle Wellen - verfeinerte Begeisterung. Ingenieure lieben dich."
}
},
{
termString: "e^(-x^2)",
location: { Growth: -0.2, Chaotic: -0.6, Logical: 0.5, Oscillation: 0 },
description: {
en: "You're the Gaussian. Centered, focused, and soothing. People come to you when they need calm clarity.",
de: "Du bist die Gauß-Funktion. Zentriert, fokussiert und beruhigend. Man kommt zu dir, wenn Ruhe und Klarheit gefragt sind."
}
},
{
termString: "cosh(x)",
location: { Growth: 0.8, Chaotic: 0.0, Logical: 0.7, Oscillation: -0.3 },
description: {
en: "You're hyperbolic cosine. Quietly dramatic—no waves, just majestic rise. Ambitious with serene poise. You won't keep anyone hanging, because you're literally the formula of a chain hanging.",
de: "Du bist der hyperbolische Kosinus. Leise dramatisch – keine Wellen, nur majestätischer Anstieg. Ehrgeizig mit gelassener Haltung. Du lässt niemanden hängen, denn du bist buchstäblich die Formel einer hängenden Kette."
}
},
{
termString: "arctan(x)",
location: { Growth: -0.2, Chaotic: 0.5, Logical: -0.9, Oscillation: -0.5 },
description: {
en: "You're arctangent. You don't get carried away—everything saturates. Wise, bounded, and great at perspective.",
de: "Du bist der Arkustangens. Du lässt dich nicht mitreißen - alles sättigt sich. Weise, begrenzt und stark in der Perspektive."
}
},
]
class Vector2d {
constructor(x, y) {
this.x = x
this.y = y
}
static get zero() {
return new Vector2d(0, 0)
}
static fromFunc(f) {
return new Vector2d(f(0), f(1))
}
copy() {
return new Vector2d(this.x, this.y)
}
add(v) {
return new Vector2d(this.x + v.x, this.y + v.y)
}
iadd(v) {
this.x += v.x
this.y += v.y
}
sub(v) {
return new Vector2d(this.x - v.x, this.y - v.y)
}
isub(v) {
this.x -= v.x
this.y -= v.y
}
mul(v) {
return new Vector2d(this.x * v.x, this.y * v.y)
}
imul(v) {
this.x *= v.x
this.y *= v.y
}
div(v) {
return new Vector2d(this.x / v.x, this.y / v.y)
}
idiv(v) {
this.x /= v.x
this.y /= v.y
}
get length() {
return Math.sqrt(this.x * this.x + this.y * this.y)
}
get normalized() {
let m = this.length
return new Vector2d(this.x / m, this.y / m)
}
scale(x) {
return new Vector2d(this.x * x, this.y * x)
}
lerp(v, t) {
let delta = v.sub(this)
return this.add(delta.scale(t))
}
dot(v) {
return this.x * v.x + this.y * v.y
}
iscale(x) {
this.x *= x
this.y *= x
}
distance(v) {
return this.sub(v).length
}
cross(v) {
return this.x * v.y - this.y * v.x
}
round() {
return new Vector2d(Math.round(this.x), Math.round(this.y))
}
static fromAngle(angle) {
return new Vector2d(Math.cos(angle), Math.sin(angle))
}
static fromPolar(mag, angle) {
return new Vector2d(mag * Math.cos(angle), mag * Math.sin(angle))
}
static fromArray(arr) {
return new Vector2d(arr[0], arr[1])
}
set(x, y) {
if (x instanceof Vector2d && y == undefined) {
this.x = x.x
this.y = x.y
} else {
this.x = x
this.y = y
}
}
addX(x) {
return new Vector2d(this.x + x, this.y)
}
addY(y) {
return new Vector2d(this.x, this.y + y)
}
rotate(angle) {
let x = this.x * Math.cos(angle) - this.y * Math.sin(angle)
let y = this.x * Math.sin(angle) + this.y * Math.cos(angle)
return new Vector2d(x, y)
}
irotate(angle) {
let x = this.x * Math.cos(angle) - this.y * Math.sin(angle)
let y = this.x * Math.sin(angle) + this.y * Math.cos(angle)
this.x = x
this.y = y
}
static random() {
let direction = Math.random() * Math.PI * 2
return Vector2d.fromAngle(direction)
}
get angle() {
return Math.atan2(this.y, this.x)
}
angleDifference(v) {
return angleDifference(this.angle, v.angle)
}
angleTo(v) {
return Math.atan2(v.y - this.y, v.x - this.x)
}
equals(v) {
return this.x == v.x && this.y == v.y
}
map(f) {
return new Vector2d(f(this.x), f(this.y))
}
product() {
return this.x * this.y
}
get array() {
return [this.x, this.y]
}
get min() {
return Math.min(...this.array)
}
get max() {
return Math.max(...this.array)
}
abs() {
return new Vector2d(Math.abs(this.x), Math.abs(this.y))
}
toArray() {
return [this.x, this.y]
}
static fromEvent(event, element) {
let x = 0, y = 0
if (event.touches && event.touches[0]) {
x = event.touches[0].clientX
y = event.touches[0].clientY
} else if (event.originalEvent && event.originalEvent.changedTouches[0]) {
x = event.originalEvent.changedTouches[0].clientX
y = event.originalEvent.changedTouches[0].clientY
} else if (event.clientX !== undefined && event.clientY !== undefined) {
x = event.clientX
y = event.clientY
} else if (event.changedTouches && event.changedTouches.length > 0) {
x = event.changedTouches[0].clientX
y = event.changedTouches[0].clientY
}
const rect = element.getBoundingClientRect()
return new Vector2d(x - rect.left, y - rect.top)
}
}
class NumberParserError extends Error {
constructor(message) {
super(message)
this.name = "NumberParserError"
}
}
class ComplexNumber {
constructor(realPart=0, imaginaryPart=0) {
this.realPart = realPart
this.imaginaryPart = imaginaryPart
}
isNumberNearlyZero(n) {
return Math.abs(n) < 1e-8
}
toArray() {
return [this.realPart, this.imaginaryPart]
}
static fromArray(arr) {
return new ComplexNumber(arr[0], arr[1])
}
static Zero() {
return new ComplexNumber(0, 0)
}
static One() {
return new ComplexNumber(1, 0)
}
static i() {
return new ComplexNumber(0, 1)
}
toString() {
if (this.realPart == 0 && this.imaginaryPart == 0) {
return "0"
}
let imaginaryString = ""
if (this.imaginaryPart == 1) {
imaginaryString = `+i`
} else if (this.imaginaryPart == -1) {
imaginaryString = "-i"
} else if (this.imaginaryPart > 0 && !this.isNumberNearlyZero(this.imaginaryPart)) {
imaginaryString = `+${this.imaginaryPart}i`
} else if (this.imaginaryPart < 0 && !this.isNumberNearlyZero(this.imaginaryPart)) {
imaginaryString = `-${-this.imaginaryPart}i`
}
if (this.isNumberNearlyZero(this.realPart)) {
if (imaginaryString.startsWith("+")) {
return imaginaryString.slice(1)
} else {
return imaginaryString
}
} else {
return `${this.realPart}${imaginaryString}`
}
}
static asComplexNumber(number) {
if (typeof number === "number") {
return new ComplexNumber(number, 0)
} else if (number instanceof ComplexNumber) {
return number
} else {
throw new Error("Failed to convert number to complex number type")
}
}
conjugate() {
return new ComplexNumber(this.realPart, -this.imaginaryPart)
}
get isReal() {
return this.isNumberNearlyZero(this.imaginaryPart)
}
magnitude() {
return Math.hypot(this.realPart, this.imaginaryPart)
}
magnitudeSquared() {
return this.realPart ** 2 + this.imaginaryPart ** 2
}
add(other) {
other = ComplexNumber.asComplexNumber(other)
return new ComplexNumber(this.realPart + other.realPart, this.imaginaryPart + other.imaginaryPart)
}
mul(other) {
other = ComplexNumber.asComplexNumber(other)
return new ComplexNumber(
this.realPart * other.realPart - this.imaginaryPart * other.imaginaryPart,
this.realPart * other.imaginaryPart + this.imaginaryPart * other.realPart
)
}
sub(other) {
other = ComplexNumber.asComplexNumber(other)
return new ComplexNumber(this.realPart - other.realPart, this.imaginaryPart - other.imaginaryPart)
}
div(other) {
other = ComplexNumber.asComplexNumber(other)
const otherSquaredMagnitude = other.magnitudeSquared()
if (otherSquaredMagnitude == 0) {
throw new Error("Zero Divison Error")
}
return new ComplexNumber(
(this.realPart * other.realPart + this.imaginaryPart * other.imaginaryPart) / otherSquaredMagnitude,
(this.imaginaryPart * other.realPart - this.realPart * other.imaginaryPart) / otherSquaredMagnitude
)
}
pow(other) {
other = ComplexNumber.asComplexNumber(other)
const [a, b] = this.toArray()
const [c, d] = other.toArray()
const r2 = this.magnitudeSquared()
if (r2 === 0) throw new RangeError("Base 0+0i is not defined for complex powers.")
const theta = Math.atan2(b, a)
const mag   = Math.pow(r2, c / 2) * Math.exp(-d * theta)
const ang   = c * theta + (d / 2) * Math.log(r2)
return new ComplexNumber(
mag * Math.cos(ang),
mag * Math.sin(ang),
)
}
sqrt() {
const a = this.realPart;
const b = this.imaginaryPart;
if (a == 0 && b == 0) return new ComplexNumber(0, 0)
const r = Math.hypot(a, b); // |z|
let u, v
if (a >= 0) {
u = Math.sqrt(0.5 * (r + a))
v = b / (2 * u)
} else {
v = Math.sqrt(0.5 * (r - a))
const s = (b >= 0 ? 1 : -1)
u = s * (b / (2 * v))
}
return new ComplexNumber(u, v)
}
abs() {
return new ComplexNumber(this.magnitude(), 0)
}
arg() {
return Math.atan2(this.imaginaryPart, this.realPart)
}
exp() {
const ea = Math.exp(this.realPart)
return new ComplexNumber(
ea * Math.cos(this.imaginaryPart),
ea * Math.sin(this.imaginaryPart)
)
}
ln() {
const r2 = this.magnitudeSquared()
if (r2 === 0) throw new RangeError("Ln(0) undefined")
return new ComplexNumber(0.5 * Math.log(r2), this.arg())
}
sin()  { const [a,b]=this.toArray(); return new ComplexNumber(Math.sin(a)*Math.cosh(b),  Math.cos(a)*Math.sinh(b)) }
cos()  { const [a,b]=this.toArray(); return new ComplexNumber(Math.cos(a)*Math.cosh(b), -Math.sin(a)*Math.sinh(b)) }
tan()  { return this.sin().div(this.cos()) }
sinh() { const [a,b]=this.toArray(); return new ComplexNumber(Math.sinh(a)*Math.cos(b),  Math.cosh(a)*Math.sin(b)) }
cosh() { const [a,b]=this.toArray(); return new ComplexNumber(Math.cosh(a)*Math.cos(b),  Math.sinh(a)*Math.sin(b)) }
tanh() { return this.sinh().div(this.cosh()) }
arcsin() {
const i = ComplexNumber.i()
return i.mul(-1).mul( i.mul(this).add( ComplexNumber.One().sub(this.mul(this)).sqrt() ).ln() )
}
arccos() {
const i = ComplexNumber.i()
return i.mul(-1).mul( this.add( this.sub(1).sqrt().mul(this.add(1).sqrt()) ).ln() )
}
arctan() {
const i = ComplexNumber.i()
return ComplexNumber.One().add(i.mul(this)).div(ComplexNumber.One().sub(i.mul(this))).ln().mul(i.mul(-0.5))
}
arcsinh() { return this.add( this.mul(this).add(1).sqrt() ).ln() }
arccosh() { return this.add( this.sub(1).sqrt().mul(this.add(1).sqrt()) ).ln() }
arctanh() { return ComplexNumber.One().add(this).div(ComplexNumber.One().sub(this)).ln().mul(0.5) }
log10() { return this.ln().div(Math.log(10)) }
log2()  { return this.ln().div(Math.log(2)) }
log3()  { return this.ln().div(Math.log(3)) }
static _lanczos() {
return [
0.99999999999980993,
676.5203681218851,
-1259.1392167224028,
771.3234287776531,
-176.6150291621406,
12.507343278686905,
-0.13857109526572012,
9.984369578019571e-6,
1.5056327351493116e-7
]
}
gamma() {
if (this.imaginaryPart === 0 && Number.isInteger(this.realPart) && this.realPart <= 0) {
throw new RangeError("Gamma pole at nonpositive integer")
}
if (this.imaginaryPart === 0) {
return new ComplexNumber(ComplexNumber._gammaReal(this.realPart), 0)
}
if (this.realPart < 0.5) {
const pi = Math.PI;
const s = this.mul(pi).sin();                // sin(πz)
const gm = ComplexNumber.One().sub(this).gamma(); // Γ(1 - z)
return new ComplexNumber(pi, 0).div(s.mul(gm));   // π / (sin(πz) Γ(1-z))
}
const p = ComplexNumber._lanczos(), g = 7;
const z1 = this.sub(1);                        // z - 1
let a = new ComplexNumber(p[0], 0);
for (let i = 1; i < p.length; i++) a = a.add(new ComplexNumber(p[i], 0).div(z1.add(i)));
const t = z1.add(g + 0.5);
const pref = new ComplexNumber(Math.sqrt(2 * Math.PI), 0);
return pref.mul(t.pow(z1.add(0.5))).mul(t.mul(-1).exp()).mul(a);
}
static _gammaReal(x) {
const p = ComplexNumber._lanczos(), g = 7;
if (x < 0.5) return Math.PI / (Math.sin(Math.PI * x) * ComplexNumber._gammaReal(1 - x));
x -= 1;
let a = p[0];
for (let i = 1; i < p.length; i++) a += p[i] / (x + i);
const t = x + g + 0.5;
return Math.sqrt(2 * Math.PI) * Math.pow(t, x + 0.5) * Math.exp(-t) * a;
}
factorial() {
if (this.imaginaryPart === 0 && Number.isInteger(this.realPart)) {
const n = this.realPart;
if (n < 0) throw new RangeError("Factorial undefined for negative integers");
let acc = 1;
for (let k = 2; k <= n; k++) acc *= k;      // fast exact product (to 170!)
return new ComplexNumber(acc, 0);
}
return this.add(1).gamma();
}
}
function evaluateNumberString(numberString) {
const constants = {
"pi": new ComplexNumber(Math.PI),
"π": new ComplexNumber(Math.PI),
"tau": new ComplexNumber(2 * Math.PI),
"phi": new ComplexNumber((1 + Math.sqrt(5)) / 2),
"Φ": new ComplexNumber((1 + Math.sqrt(5)) / 2),
"goldenratio": new ComplexNumber((1 + Math.sqrt(5)) / 2),
"e": new ComplexNumber(Math.E),
"i": new ComplexNumber(0, 1)
}
for (const [constant, value] of Object.entries(constants)) {
if (numberString == constant) {
return value
}
}
if (numberString.startsWith("-")) {
return evaluateNumberString("0" + numberString)
}
if (numberString == "inf") {
throw new NumberParserError(`Infinity is not a number`)
}
const imaginaryRegex = /^[0123456789]+(\.[0123456789]+)?i$/
const decimalRegex = /^[0123456789]+\.[0123456789]+$/
const intRegex = /^[0123456789]+$/
const hexDecimalRegex = /^0x[0123456789abcdef]+\.[0123456789abcdef]+$/
const hexIntRegex = /^0x[0123456789abcdef]+$/
const binDecimalRegex = /^0b[01]+\.[01]+$/
const binIntRegex = /^0b[01]+$/
const scientificRegex = /^\-?[0123456789]+(\.[0123456789]+)?e-?[0123456789]+$/
const allowedFunctions = {
"sqrt":    {compute: n => ComplexNumber.asComplexNumber(n).sqrt()},
"abs":     {compute: n => ComplexNumber.asComplexNumber(n).abs()},
"sin":     {compute: n => ComplexNumber.asComplexNumber(n).sin()},
"cos":     {compute: n => ComplexNumber.asComplexNumber(n).cos()},
"tan":     {compute: n => ComplexNumber.asComplexNumber(n).tan()},
"arcsin":  {compute: n => ComplexNumber.asComplexNumber(n).arcsin()},
"arccos":  {compute: n => ComplexNumber.asComplexNumber(n).arccos()},
"arctan":  {compute: n => ComplexNumber.asComplexNumber(n).arctan()},
"sinh":    {compute: n => ComplexNumber.asComplexNumber(n).sinh()},
"cosh":    {compute: n => ComplexNumber.asComplexNumber(n).cosh()},
"tanh":    {compute: n => ComplexNumber.asComplexNumber(n).tanh()},
"arcsinh": {compute: n => ComplexNumber.asComplexNumber(n).arcsinh()},
"arccosh": {compute: n => ComplexNumber.asComplexNumber(n).arccosh()},
"arctanh": {compute: n => ComplexNumber.asComplexNumber(n).arctanh()},
"log":     {compute: n => ComplexNumber.asComplexNumber(n).ln()},
"ln":      {compute: n => ComplexNumber.asComplexNumber(n).ln()},
"log10":   {compute: n => ComplexNumber.asComplexNumber(n).log10()},
"log2":    {compute: n => ComplexNumber.asComplexNumber(n).log2()},
"log3":    {compute: n => ComplexNumber.asComplexNumber(n).log3()},
"factorial": {compute: n => ComplexNumber.asComplexNumber(n).factorial()},
"gamma":  {compute: n => ComplexNumber.asComplexNumber(n).gamma()},
"Γ":       {compute: n => ComplexNumber.asComplexNumber(n).gamma()},
"exp":     {compute: n => ComplexNumber.asComplexNumber(n).exp()},
"":        {compute: n => ComplexNumber.asComplexNumber(n)},
}
for (const [functionStr, func] of Object.entries(allowedFunctions)) {
if (numberString.startsWith(`${functionStr}(`)) {
const numberPart = numberString.slice(functionStr.length + 1, -1)
let openCount = 0
let abortThisExecution = false
for (const char of numberPart) {
if (char == "(") {
openCount++
} else if (char == ")") {
openCount--
}
if (openCount < 0) {
abortThisExecution = true
break
}
}
if (abortThisExecution) {
continue
}
const value = evaluateNumberString(numberPart)
for (const constraint of (func.constraints ?? [])) {
if (constraint.if(value)) {
throw constraint.err()
}
}
return func.compute(value)
}
}
if (intRegex.test(numberString)) {
return new ComplexNumber(parseInt(numberString))
} else if (hexIntRegex.test(numberString)) {
return new ComplexNumber(parseInt(numberString.slice(2), 16))
} else if (binIntRegex.test(numberString)) {
return new ComplexNumber(parseInt(numberString.slice(2), 2))
}
if (imaginaryRegex.test(numberString)) {
return new ComplexNumber(0, parseFloat(numberString.slice(0, -1)))
} else if (decimalRegex.test(numberString)) {
return new ComplexNumber(parseFloat(numberString))
} else if (binDecimalRegex.test(numberString)) {
const [before, after] = numberString.split(".")
const beforeVal = parseInt(before.slice(2), 2)
const afterVal = parseInt(after, 2)
return new ComplexNumber(beforeVal + afterVal / (2 ** after.length))
} else if (hexDecimalRegex.test(numberString)) {
const [before, after] = numberString.split(".")
const beforeVal = parseInt(before.slice(2), 16)
const afterVal = parseInt(after, 16)
return new ComplexNumber(beforeVal + afterVal / (16 ** after.length))
}
if (scientificRegex.test(numberString)) {
let [decimal, exponent] = numberString.split("e")
decimal = parseFloat(decimal)
exponent = parseInt(exponent)
return new ComplexNumber(decimal * (10 ** exponent))
}
const operators = [
["+", (a, b) => a.add(b)],
["-", (a, b) => a.sub(b)],
["*", (a, b) => a.mul(b)],
["/", (a, b) => a.div(b)],
["^", (a, b) => a.pow(b)],
]
for (const [operatorName, operatorFunc] of operators) {
let currLevel = 0
let foundSplitIndex = null
for (let i = 0; i < numberString.length; i++) {
const char = numberString[i]
if (char == "(") currLevel++
if (char == ")") currLevel--
if (currLevel < 0) {
throw new NumberParserError(`Unbalanced parentheses`)
}
if (char == operatorName && currLevel == 0) {
foundSplitIndex = i
}
}
if (currLevel != 0) {
throw new NumberParserError(`Unbalanced parentheses`)
}
if (foundSplitIndex === null) {
continue
}
const parts = [
numberString.slice(0, foundSplitIndex),
numberString.slice(foundSplitIndex + 1)
]
for (let i = 0; i < 2; i++) {
parts[i] = evaluateNumberString(parts[i])
}
if (parts[1] == 0 && operatorName == "/") {
throw new NumberParserError(`Can't divide by zero`)
}
return operatorFunc(parts[0], parts[1])
}
if (numberString.startsWith("-")) {
return -evaluateNumberString(numberString.slice(1))
}
throw new NumberParserError(`Invalid number`)
}
class WurzleFunction {
constructor(termString) {
this.termString = termString
}
computeAt(x) {
const y = evaluateNumberString(this.termString.replaceAll("x", `(${x})`))
if (!y.isReal) {
throw new NumberParserError("Expected Real Number, got Complex")
} else {
return y.realPart
}
}
numericToStringResult(y) {
y = ComplexNumber.asComplexNumber(y).realPart
const maxPositiveNumber = 10 ** (NUM_CELLS_PER_ROW - 1) - 1
const maxNegativeNumber = -(10 ** (NUM_CELLS_PER_ROW - 2) - 1)
if (y > maxPositiveNumber) {
return ">" + maxPositiveNumber
} else if (y < maxNegativeNumber) {
return "<" + maxNegativeNumber
} else {
let yString = null
for (let n = 0; n <= NUM_CELLS_PER_ROW; n++) {
yString = (y >= 0 && y < 10) ? ("0" + y.toFixed(n)) : y.toFixed(n)
if (yString.length == NUM_CELLS_PER_ROW - 1) {
break
} else if (yString.length >= NUM_CELLS_PER_ROW) {
yString = yString.slice(0, NUM_CELLS_PER_ROW - 1)
}
}
if (parseFloat(yString) == y) {
return `=${yString}`
} else {
return `≈${yString}`
}
}
}
computeStringResultAt(x) {
let y = null
try {
y = this.computeAt(x)
} catch (e) {
if (e instanceof NumberParserError) {
if (e.message === "Expected Real Number, got Complex") {
return "unreal".slice(0, NUM_CELLS_PER_ROW).padStart(NUM_CELLS_PER_ROW, " ")
}
return "undefined".slice(0, NUM_CELLS_PER_ROW).padStart(NUM_CELLS_PER_ROW, " ")
} else {
throw e
}
}
return this.numericToStringResult(y)
}
}
class FunctionPlotter {
constructor(canvas, context, viewCentre, viewHeight) {
this.canvas = canvas
this.context = context ?? canvas.getContext("2d")
this.viewCentre = viewCentre ?? new Vector2d(0, 0)
this.viewHeight = viewHeight ?? 5
this.wurzleFunctions = []
this.guessedPoints = []
}
removeAllFunctions() {
this.wurzleFunctions = []
}
get defaultForegroundColor() {
return getComputedStyle(document.body).getPropertyValue("--card-text-color")
}
get defaultBackgroundColor() {
return getComputedStyle(document.body).getPropertyValue("--header-button-background")
}
get viewWidth() {
return this.canvas.width / this.canvas.height * this.viewHeight
}
pointToScreenPos(point) {
const relativePoint = point.sub(this.viewCentre)
return new Vector2d(
(relativePoint.x / (this.viewWidth) + 0.5) * this.canvas.width,
(-relativePoint.y / (this.viewHeight) + 0.5) * this.canvas.height
)
}
screenPosToPoint(screenPos) {
const x = (screenPos.x / this.canvas.width - 0.5) * this.viewWidth
const y = -(screenPos.y / this.canvas.height - 0.5) * this.viewHeight
const relativePoint = new Vector2d(x, y)
return relativePoint.add(this.viewCentre)
}
clear() {
this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
}
drawPoint(point, {atScreenPos=false, radius=5, color="blue",
label=null, labelSize=13, labelColor=null, labelOffset=null,
labelBaseline="top", labelAlign="left"
}={}) {
labelColor ??= this.defaultForegroundColor
this.context.beginPath()
let screenPos = null
if (atScreenPos) {
screenPos = point
} else {
screenPos = this.pointToScreenPos(point)
}
this.context.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2)
this.context.fillStyle = color
this.context.fill()
if (label !== null) {
this.context.fillStyle = labelColor
this.context.textAlign = labelAlign
this.context.textBaseline = labelBaseline
this.context.font = `${labelSize}px monospace`
const labelPos = screenPos.addX(radius).addY(radius)
if (labelOffset !== null) {
labelPos.iadd(labelOffset.scale(labelSize))
}
this.context.fillText(label, screenPos.x + radius, screenPos.y + radius)
}
}
connectPoints(points, {atScreenPos=false, color=null, width=1}={}) {
color ??= this.defaultForegroundColor
this.context.strokeStyle = color
this.context.lineWidth = width
this.context.beginPath()
for (let i = 0; i < points.length; i++) {
const screenPos = atScreenPos ? points[i] : this.pointToScreenPos(points[i])
if (i == 0) {
this.context.moveTo(screenPos.x, screenPos.y)
} else {
this.context.lineTo(screenPos.x, screenPos.y)
}
}
this.context.stroke()
}
drawAxes() {
const minXY = this.screenPosToPoint(new Vector2d(0, this.canvas.height))
const maxXY = this.screenPosToPoint(new Vector2d(this.canvas.width, 0))
this.connectPoints([
new Vector2d(Math.floor(minXY.x) - 1, 0),
new Vector2d(Math.ceil(maxXY.x) + 1, 0)
])
this.connectPoints([
new Vector2d(0, Math.floor(minXY.y) - 1),
new Vector2d(0, Math.ceil(maxXY.y) + 1)
])
const pinStyling = {color: this.defaultForegroundColor, radius: 3}
let numTicksVisible = Math.max(
Math.ceil(maxXY.x) - Math.floor(minXY.x),
Math.ceil(maxXY.y) - Math.floor(minXY.y)
) * 10
let stepSize = 0.1
let i = 0
while (numTicksVisible > 20) {
const factor = (i % 2 == 0) ? 2 : 5
stepSize *= factor
numTicksVisible /= factor
i++
}
let startX = Math.floor(minXY.x)
startX -= startX % stepSize
for (let x = startX; x <= Math.ceil(maxXY.x); x += stepSize) {
if (x == 0) continue
this.drawPoint(new Vector2d(x, 0), {label: Math.round(x * 10) / 10, ...pinStyling})
}
let startY = Math.floor(minXY.y)
startY -= startY % stepSize
for (let y = startY; y <= Math.ceil(maxXY.y); y += stepSize) {
this.drawPoint(new Vector2d(0, y), {label: Math.round(y * 10) / 10, ...pinStyling})
}
}
plot(wurzleFunction, color="blue") {
const points = Array.from({length: this.canvas.width})
.map((_, i) => this.screenPosToPoint(new Vector2d(i, 0)).x)
.map(x => {
try {
const y = wurzleFunction.computeAt(x)
if (isNaN(y)) {
throw new Error("Value may not be NaN")
}
return new Vector2d(x, y)
} catch {
return null
}
})
const maxDelta = 10
let drewAtLeastOnePoint = false
for (let i = 1; i < points.length; i++) {
const [p1, p2] = [points[i - 1], points[i]]
if (p1 === null || p2 === null) {
continue
}
if (p1.distance(p2) < maxDelta) {
this.connectPoints([p1, p2], {color})
drewAtLeastOnePoint = true
}
}
return drewAtLeastOnePoint
}
addFunction(wurzleFunction) {
this.wurzleFunctions.push(wurzleFunction)
}
removeFunction(wurzleFunction) {
this.wurzleFunctions = this.wurzleFunctions.filter(f => f.termString != wurzleFunction.termString)
}
makeInteractive() {
const redraw = () => {
this.canvas.width = this.canvas.clientWidth
this.canvas.height = this.canvas.clientHeight
this.clear()
this.drawAxes()
let drewAtLeastOnePoint = false
for (const func of this.wurzleFunctions) {
if (this.plot(func)) {
drewAtLeastOnePoint = true
}
}
for (let i = 0; i < this.guessedPoints.length; i++) {
this.drawPoint(this.guessedPoints[i])
}
return drewAtLeastOnePoint
}
this.canvas.addEventListener("wheel", event => {
this.viewHeight *= event.deltaY / 1000 + 1
event.preventDefault()
redraw()
})
let dragPoint = null
let dragStartViewCentre = null
const mousedown = event => {
dragPoint = this.screenPosToPoint(Vector2d.fromEvent(event, this.canvas))
dragStartViewCentre = this.viewCentre.copy()
}
const mousemove = event => {
if (!dragPoint) {
return
}
let temp = this.viewCentre.copy()
this.viewCentre = dragStartViewCentre
const delta = this.screenPosToPoint(Vector2d.fromEvent(event, this.canvas)).sub(dragPoint)
this.viewCentre = temp.copy()
event.preventDefault()
this.viewCentre = dragStartViewCentre.sub(delta)
redraw()
}
const mouseup = event => {
dragPoint = null
dragStartViewCentre = null
}
this.canvas.addEventListener("mousedown", mousedown)
this.canvas.addEventListener("mousemove", mousemove)
this.canvas.addEventListener("mouseup", mouseup)
this.canvas.addEventListener("touchstart", mousedown)
this.canvas.addEventListener("touchmove", mousemove)
this.canvas.addEventListener("touchend", mouseup)
window.addEventListener("resize", redraw)
redraw()
return {redraw}
}
}
const urlParams = new URLSearchParams(window.location.search)
class PersonalityTest {
constructor(questions) {
this.questions = questions.map(q => {
q.answerIndex = urlParams.has("r") ? Math.floor(Math.random() * NUM_BUTTONS_PER_QUESTION) : null
return q
})
shuffle(this.questions)
}
initHtml() {
this.questionContainers = []
questionsContainer.innerHTML = ""
let nextQuestionIndex = 0
for (const question of this.questions) {
nextQuestionIndex++
const questionContainer = document.createElement("div")
questionContainer.classList.add("question-container")
const questionHeader = document.createElement("div")
questionHeader.classList.add("question-header")
for (const [langKey, langValue] of Object.entries(question.statement)) {
const questionHeaderText = document.createElement("div")
questionHeaderText.classList.add("question-header-text")
questionHeaderText.textContent = `(${nextQuestionIndex}/${this.questions.length}) ${langValue}`
questionHeaderText.setAttribute("lang", langKey)
questionHeader.appendChild(questionHeaderText)
}
const questionBody = document.createElement("div")
questionBody.classList.add("question-body")
const questionButtonsContainer = document.createElement("div")
questionButtonsContainer.classList.add("question-buttons-container")
const allQuestionButtons = []
const updateButtons = () => {
for (let i = 0; i < NUM_BUTTONS_PER_QUESTION; i++) {
const button = allQuestionButtons[i]
if (i === question.answerIndex) {
button.classList.add("selected")
button.classList.remove("noanswer")
} else {
button.classList.remove("selected")
button.classList.remove("noanswer")
}
if (question.answerIndex === null) {
button.classList.add("noanswer")
button.classList.remove("selected")
}
}
if (question.answerIndex !== null) {
questionContainer.classList.add("answered")
} else {
questionContainer.classList.remove("answered")
}
}
for (let i = 0; i < NUM_BUTTONS_PER_QUESTION; i++) {
const questionButton = document.createElement("button")
questionButton.classList.add("question-button")
allQuestionButtons.push(questionButton)
questionButtonsContainer.appendChild(questionButton)
questionButton.addEventListener("click", () => {
if (showingResults) return
question.answerIndex = i
updateButtons()
const smallestUnselectedIndex = this.getUnfinishedQuestionIndex()
if (smallestUnselectedIndex !== null && this.questionContainers[smallestUnselectedIndex]) {
this.questionContainers[smallestUnselectedIndex].scrollIntoView({
behavior: "smooth",
block: "center"
})
} else if (smallestUnselectedIndex === null) {
finishQuestionsButton.scrollIntoView({
behavior: "smooth",
block: "center"
})
}
})
}
updateButtons()
const questionExplainContainer = document.createElement("div")
questionExplainContainer.classList.add("question-explain-container")
const questionAgree = document.createElement("div")
questionAgree.classList.add("agree")
const questionDisagree = document.createElement("div")
questionDisagree.classList.add("disagree")
questionExplainContainer.appendChild(questionAgree)
questionExplainContainer.appendChild(questionDisagree)
questionBody.appendChild(questionButtonsContainer)
questionBody.appendChild(questionExplainContainer)
questionContainer.appendChild(questionHeader)
questionContainer.appendChild(questionBody)
questionsContainer.appendChild(questionContainer)
this.questionContainers.push(questionContainer)
}
}
computeResults() {
const result = Object.fromEntries(Array.from(Object.keys(TestResultCategories)).map(key => [key, 0]))
const halfNumButtons = Math.floor(NUM_BUTTONS_PER_QUESTION / 2)
for (const question of this.questions) {
if (question.answerIndex === null) continue
const agreement = (halfNumButtons - question.answerIndex) / halfNumButtons
const agreementFactor = (agreement + 1) / 2
const effectKeys = Object.keys(question.effect.agree)
for (const key of effectKeys) {
const agreeEffect = question.effect.agree[key] || 0
const disagreeEffect = question.effect.disagree[key] || 0
const interpolatedEffect = agreeEffect * agreementFactor + disagreeEffect * (1 - agreementFactor)
result[key] += interpolatedEffect
}
}
const sigmoid = x => 2 / (1 + Math.exp(-x)) - 1
for (const key of Object.keys(result)) {
result[key] = sigmoid(result[key])
result[key] = Math.round(result[key] * 100) / 100 // round to 2 decimal places
}
return result
}
computePersonality() {
const result = this.computeResults()
let personality = {}
let bestDistance = Infinity
for (const testResult of TestResults) {
const distance = Object.keys(result).reduce((sum, key) => {
return sum + Math.pow(result[key] - testResult.location[key], 2)
}, 0)
if (distance < bestDistance) {
bestDistance = distance
personality = testResult
}
}
return personality
}
computePersonalityScores() {
const result = this.computeResults()
const maxDistance = 2 * Math.sqrt(Object.keys(result).length)
const results = TestResults.map(testResult => {
const distance = Math.sqrt(Object.keys(result).reduce((sum, key) => {
return sum + Math.pow(result[key] - testResult.location[key], 2)
}, 0))
return {
name: testResult.termString,
distance: distance
}
})
results.sort((a, b) => a.distance - b.distance)
const scores = results.map(result => {
return {
name: result.name,
score: Math.round(((1 - result.distance / maxDistance) ** 2) * 10000) / 100
}
})
return scores
}
getUnfinishedQuestionIndex() {
for (let i = 0; i < this.questions.length; i++) {
if (this.questions[i].answerIndex === null) {
return i
}
}
return null
}
}
const test = new PersonalityTest(TestQuestions)
test.initHtml()
let showingResults = false
finishQuestionsButton.addEventListener("click", () => {
const unfinishedQuestionIndex = test.getUnfinishedQuestionIndex()
if (unfinishedQuestionIndex !== null) {
test.questionContainers[unfinishedQuestionIndex].scrollIntoView({ behavior: "smooth", block: "center" })
return
}
showingResults = true
resultsContainer.style.display = "block"
const personality = test.computePersonality()
resultFunction.textContent = `f(x) = ${personality.termString}`
for (const [langKey, langValue] of Object.entries(personality.description)) {
const resultDescriptionText = document.createElement("div")
resultDescriptionText.classList.add("result-description-text")
resultDescriptionText.textContent = langValue
resultDescriptionText.setAttribute("lang", langKey)
resultDescription.appendChild(resultDescriptionText)
}
setTimeout(() => {
resultsContainer.scrollIntoView({ behavior: "smooth", block: "start" })
}, 100)
finishQuestionsButton.remove()
const f = new WurzleFunction(personality.termString)
const plotter = new FunctionPlotter(resultFunctionCanvas, resultFunctionContext)
plotter.viewCentre = new Vector2d(0, 0)
plotter.viewHeight = 12
plotter.addFunction(f)
plotter.makeInteractive()
const personalityScores = test.computePersonalityScores()
for (const {name, score} of personalityScores) {
const row = document.createElement("tr")
const nameCell = document.createElement("td")
nameCell.textContent = name
const scoreCell = document.createElement("td")
scoreCell.textContent = score.toFixed(2)
row.appendChild(nameCell)
row.appendChild(scoreCell)
resultsTableBody.appendChild(row)
}
})
