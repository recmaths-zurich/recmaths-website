const wurzleGameContainer = document.getElementById("wurzle-game-container")
const wurzleGridContainer = document.getElementById("wurzle-grid-container")
const wurzleGlobalContainer = document.getElementById("wurzle-global-container")
const wurzleInput = document.getElementById("wurzle-input")
const wurzleSubmitButton = document.getElementById("wurzle-submit-button")
const wurzleInputContainer = document.getElementById("wurzle-input-container")
const wurzleShareContainer = document.getElementById("wurzle-share-container")
const wurzleResultsPopup = document.getElementById("wurzle-results-popup")
const wurzleGoodResultsContainer = document.getElementById("wurzle-good-results-container")
const wurzleBadResultsContainer = document.getElementById("wurzle-bad-results-container")
const wurzlePopupBackground = document.getElementById("wurzle-popup-background")
const wurzleClosePopupButton = document.getElementById("close-popup-button")
const revealFunctionButtons = document.querySelectorAll(".function-reveal-button")
const shareResultsButtons = document.querySelectorAll(".share-results-button")
const showResultsButton = document.getElementById("show-results-button")
const enableTrainingModeButton = document.getElementById("enable-training-mode-button")
const disableTrainingModeButton = document.getElementById("disable-training-mode-button")
const calendarContainer = document.getElementById("wurzle-calendar-container")
const NUM_CELLS_PER_ROW = 6
const NUM_MAX_GUESSES = 12
const POPUP_ANIMATION_MS = 300
const POPUP_ANIMATION_EASING_IN = "ease-out"
const POPUP_ANIMATION_EASING_OUT = "ease-in"
wurzleGameContainer.style.setProperty("--num-cells-per-row", NUM_CELLS_PER_ROW)
function updateCSSCellSize(recurse=true) {
const cell = wurzleGridContainer.querySelector(".wurzle-grid-cell")
if (cell) {
const cellSize = cell.offsetWidth ?? cell.clientWidth
wurzleGlobalContainer.style.setProperty("--cell-size-px", `${cellSize}px`)
}
if (recurse) {
setTimeout(updateCSSCellSize.bind(null, false), 0)
}
}
function fillDataElements(key, value) {
for (const element of document.querySelectorAll(`[data-fill='${key}']`)) {
element.textContent = value
}
}
function revealElements(revealKey) {
for (const element of document.querySelectorAll(`[data-revealwhen='${revealKey}']`)) {
element.style.display = "block"
}
}
function hideElements(revealKey) {
for (const element of document.querySelectorAll(`[data-revealwhen='${revealKey}']`)) {
element.style.display = "none"
}
}
fillDataElements("max-num-guesses", NUM_MAX_GUESSES)
window.addEventListener("resize", updateCSSCellSize)
window.addEventListener("DOMContentLoaded", updateCSSCellSize)
const CELL_HIDDEN_BACKGROUND_COLOR = "var(--cell-hidden-color)"
const CELL_BAD_BACKGROUND_COLOR = "var(--result-cell-bad-background-color)"
const CELL_BAD_FOREGROUND_COLOR = "var(--result-cell-bad-foreground-color)"
const CELL_GOOD_FOREGROUND_COLOR = "var(--result-cell-good-foreground-color)"
const CELL_GOOD_BACKGROUND_COLOR = "var(--result-cell-good-background-color)"
let redrawActivePlot = null
function showPopup() {
wurzlePopupBackground.style.display = "block"
wurzleResultsPopup.style.display = "block"
wurzleInputContainer.style.display = "none"
wurzleShareContainer.style.display = "block"
wurzlePopupBackground.animate([
{ opacity: 0 },
{ opacity: 1 }
], {duration: POPUP_ANIMATION_MS, easing: POPUP_ANIMATION_EASING_IN})
wurzleResultsPopup.animate([
{ transform: "translate(-50%, -200vh)" },
{ transform: "translate(-50%, -50%)" }
], {duration: POPUP_ANIMATION_MS, easing: POPUP_ANIMATION_EASING_IN})
if (redrawActivePlot !== null) {
redrawActivePlot()
}
}
function hidePopup() {
wurzlePopupBackground.animate([
{ opacity: 1 },
{ opacity: 0 }
], {duration: POPUP_ANIMATION_MS, easing: POPUP_ANIMATION_EASING_OUT}).finished.then(() => {
wurzlePopupBackground.style.display = "none"
})
wurzleResultsPopup.animate([
{ transform: "translate(-50%, -50%)" },
{ transform: "translate(-50%, -200vh)" }
], {duration: POPUP_ANIMATION_MS, easing: POPUP_ANIMATION_EASING_OUT}).finished.then(() => {
wurzleResultsPopup.style.display = "none"
})
}
const CalendarMonth = {
January: 1, February: 2, March: 3,
April: 4, May: 5, June: 6,
July: 7, August: 8, September: 9,
October: 10, November: 11, December: 12
}
const CalendarMonthNames = {
"de": {
[CalendarMonth.January]: "Januar",
[CalendarMonth.February]: "Februar",
[CalendarMonth.March]: "März",
[CalendarMonth.April]: "April",
[CalendarMonth.May]: "Mai",
[CalendarMonth.June]: "Juni",
[CalendarMonth.July]: "Juli",
[CalendarMonth.August]: "August",
[CalendarMonth.September]: "September",
[CalendarMonth.October]: "Oktober",
[CalendarMonth.November]: "November",
[CalendarMonth.December]: "Dezember"
},
"en": {
[CalendarMonth.January]: "January",
[CalendarMonth.February]: "February",
[CalendarMonth.March]: "March",
[CalendarMonth.April]: "April",
[CalendarMonth.May]: "May",
[CalendarMonth.June]: "June",
[CalendarMonth.July]: "July",
[CalendarMonth.August]: "August",
[CalendarMonth.September]: "September",
[CalendarMonth.October]: "October",
[CalendarMonth.November]: "November",
[CalendarMonth.December]: "December"
}
}
class CalendarWidget {
constructor(containerElement) {
this.containerElement = containerElement
this.events = []
this.currMonth = null
this.currYear = null
}
addClickableDay(day, month, year, {
title="",
func=() => {},
color=null
}={}) {
this.events.push({day, month, year, title, func, color})
}
_getDayIndex(date) {
const sundayOrientedDay = date.getDay()
if (sundayOrientedDay == 0) {
return 6
} else {
return sundayOrientedDay - 1
}
}
changeMonthBy(increment) {
this.currMonth += increment
while (this.currMonth < 1) {
this.currMonth += 12
this.currYear--
}
while (this.currMonth > 12) {
this.currMonth -= 12
this.currYear++
}
this.update()
}
showMonth(month, year) {
this.containerElement.innerHTML = ""
const header = document.createElement("div")
header.classList.add("calendar-header")
const monthName = CalendarMonthNames[document.documentElement.lang][month]
const headerSpan = document.createElement("span")
headerSpan.textContent = `${monthName} ${year}`
const prevButton = document.createElement("div")
prevButton.classList.add("calendar-button")
prevButton.textContent = "◀"
const nextButton = document.createElement("div")
nextButton.classList.add("calendar-button")
nextButton.textContent = "▶"
prevButton.addEventListener("click", () => this.changeMonthBy(-1))
nextButton.addEventListener("click", () => this.changeMonthBy(1))
header.appendChild(prevButton)
header.appendChild(headerSpan)
header.appendChild(nextButton)
this.containerElement.appendChild(header)
const allDayDates = []
let currDate = new Date(Date.UTC(year, month - 1))
while (currDate.getUTCMonth() == month - 1) {
allDayDates.push(new Date(currDate.getTime()))
currDate.setUTCDate(currDate.getUTCDate() + 1)
}
const gridOffset = this._getDayIndex(allDayDates[0])
const flatGrid = Array.from({length: gridOffset}, () => null)
.concat(allDayDates.map((_, i) => i + 1))
const gridHeight = Math.ceil(flatGrid.length / 7)
const gridValues = Array.from({length: gridHeight})
.map((_, i) => Array.from({length: 7}).map((_, j) => flatGrid[i * 7 + j] ?? null))
const gridContainer = document.createElement("div")
gridContainer.classList.add("calendar-grid")
const today = new Date()
for (const gridRow of gridValues) {
for (const gridCell of gridRow) {
const cellElement = document.createElement("div")
cellElement.classList.add("calendar-cell")
cellElement.textContent = gridCell
gridContainer.appendChild(cellElement)
for (const event of this.events) {
if (event.year != year || event.month != month || event.day != gridCell) {
continue
}
cellElement.title = event.title
cellElement.classList.add("clickable")
cellElement.addEventListener("click", event.func)
if (event.color) {
cellElement.style.backgroundColor = event.color
}
}
if (today.getFullYear() == year && today.getMonth() + 1 == month && today.getDate() == gridCell) {
cellElement.classList.add("today")
}
}
}
this.containerElement.appendChild(gridContainer)
this.currMonth = month
this.currYear = year
}
update() {
if (this.currMonth && this.currYear) {
this.showMonth(this.currMonth, this.currYear)
}
}
showCurrentMonth() {
const now = new Date()
this.currMonth = now.getMonth()
this.currYear = now.getFullYear()
this.changeMonthBy(1)
}
}
const calendarWidget = new CalendarWidget(calendarContainer)
calendarWidget.showCurrentMonth()
class NumberParserError extends Error {
constructor(message) {
super(message)
this.name = "NumberParserError"
}
}
function evaluateNumberString(numberString) {
const constants = {
"pi": Math.PI,
"π": Math.PI,
"tau": 2 * Math.PI,
"phi": (1 + Math.sqrt(5)) / 2,
"Φ": (1 + Math.sqrt(5)) / 2,
"goldenratio": (1 + Math.sqrt(5)) / 2,
"e": Math.E,
}
for (const [constant, value] of Object.entries(constants)) {
if (numberString == constant) {
return value
}
}
if (numberString.startsWith("-")) {
return evaluateNumberString("0" + numberString)
}
if (numberString == "inf") {
throw new NumberParserError(`Infinity is not a number`)
}
const decimalRegex = /^[0123456789]+\.[0123456789]+$/
const intRegex = /^[0123456789]+$/
const hexDecimalRegex = /^0x[0123456789abcdef]+\.[0123456789abcdef]+$/
const hexIntRegex = /^0x[0123456789abcdef]+$/
const binDecimalRegex = /^0b[01]+\.[01]+$/
const binIntRegex = /^0b[01]+$/
const scientificRegex = /^\-?[0123456789]+(\.[0123456789]+)?e-?[0123456789]+$/
const allowedFunctions = {
"sqrt": {
compute: n => Math.sqrt(n),
constraints: [
{
if: n => (n < 0),
err: () => new NumberParserError(`sqrt is only defined on [0, inf)`)
}
]
},
"abs":     {compute: n => Math.abs(n)},
"sin":     {compute: n => Math.sin(n)},
"cos":     {compute: n => Math.cos(n)},
"tan":     {compute: n => Math.tan(n)},
"arcsin":  {
compute: n => Math.asin(n),
constraints: [
{
if: n => (n < -1) || (n > 1),
err: () => new NumberParserError(`arcsin is only defined on [-1, 1]`)
}
]
},
"arccos":  {
compute: n => Math.acos(n),
constraints: [
{
if: n => (n < -1) || (n > 1),
err: () => new NumberParserError(`arccos is only defined on [-1, 1]`)
}
]
},
"arctan":  {compute: n => Math.atan(n)},
"sinh":    {compute: n => Math.sinh(n)},
"cosh":    {compute: n => Math.cosh(n)},
"tanh":    {compute: n => Math.tanh(n)},
"arcsinh": {compute: n => Math.asinh(n)},
"ln":      {
compute: n => Math.log(n),
constraints: [{
if: n => (n <= 0),
err: () => new NumberParserError("ln is only defined on (0, inf)")
}]
},
"log10":   {
compute: n => Math.log10(n),
constraints: [{
if: n => (n <= 0),
err: () => new NumberParserError("log10 is only defined on (0, inf)")
}]
},
"log2":    {
compute: n => Math.log2(n),
constraints: [{
if: n => (n <= 0),
err: () => new NumberParserError("log2 is only defined on (0, inf)")
}]
},
"log3":    {
compute: n => Math.log(n) / Math.log(3),
constraints: [{
if: n => (n <= 0),
err: () => new NumberParserError("log3 is only defined on (0, inf)")
}]
},
"arccosh": {
compute: n => Math.acosh(n),
constraints: [
{
if: n => (n < 1),
err: () => new NumberParserError(`arccosh is only defined on [1, inf)`)
}
]
},
"arctanh": {
compute: n => Math.atanh(n),
constraints: [
{
if: n => (n <= -1) || (n >= 1),
err: () => new NumberParserError(`arctanh is only defined on (-1, 1)`)
}
]
},
"": {compute: n => n}
}
for (const [functionStr, func] of Object.entries(allowedFunctions)) {
if (numberString.startsWith(`${functionStr}(`)) {
const numberPart = numberString.slice(functionStr.length + 1, -1)
let openCount = 0
let abortThisExecution = false
for (const char of numberPart) {
if (char == "(") {
openCount++
} else if (char == ")") {
openCount--
}
if (openCount < 0) {
abortThisExecution = true
break
}
}
if (abortThisExecution) {
continue
}
const value = evaluateNumberString(numberPart)
for (const constraint of (func.constraints ?? [])) {
if (constraint.if(value)) {
throw constraint.err()
}
}
return func.compute(value)
}
}
if (intRegex.test(numberString)) {
return parseInt(numberString)
} else if (hexIntRegex.test(numberString)) {
return parseInt(numberString.slice(2), 16)
} else if (binIntRegex.test(numberString)) {
return parseInt(numberString.slice(2), 2)
}
if (decimalRegex.test(numberString)) {
return parseFloat(numberString)
} else if (binDecimalRegex.test(numberString)) {
const [before, after] = numberString.split(".")
const beforeVal = parseInt(before.slice(2), 2)
const afterVal = parseInt(after, 2)
return beforeVal + afterVal / (2 ** after.length)
} else if (hexDecimalRegex.test(numberString)) {
const [before, after] = numberString.split(".")
const beforeVal = parseInt(before.slice(2), 16)
const afterVal = parseInt(after, 16)
return beforeVal + afterVal / (16 ** after.length)
}
if (scientificRegex.test(numberString)) {
let [decimal, exponent] = numberString.split("e")
decimal = parseFloat(decimal)
exponent = parseInt(exponent)
return decimal * (10 ** exponent)
}
const operators = [
["+", (a, b) => a + b],
["-", (a, b) => a - b],
["*", (a, b) => a * b],
["/", (a, b) => a / b],
["^", (a, b) => a ** b],
]
for (const [operatorName, operatorFunc] of operators) {
let currLevel = 0
let foundSplitIndex = null
for (let i = 0; i < numberString.length; i++) {
const char = numberString[i]
if (char == "(") currLevel++
if (char == ")") currLevel--
if (currLevel < 0) {
throw new NumberParserError(`Unbalanced parentheses`)
}
if (char == operatorName && currLevel == 0) {
foundSplitIndex = i
}
}
if (currLevel != 0) {
throw new NumberParserError(`Unbalanced parentheses`)
}
if (foundSplitIndex === null) {
continue
}
const parts = [
numberString.slice(0, foundSplitIndex),
numberString.slice(foundSplitIndex + 1)
]
for (let i = 0; i < 2; i++) {
parts[i] = evaluateNumberString(parts[i])
}
if (parts[1] == 0 && operatorName == "/") {
throw new NumberParserError(`Can't divide by zero`)
}
return operatorFunc(parts[0], parts[1])
}
if (numberString.startsWith("-")) {
return -evaluateNumberString(numberString.slice(1))
}
throw new NumberParserError(`Invalid number`)
}
class WurzleFunction {
constructor(termString) {
this.termString = termString
}
computeAt(x) {
return evaluateNumberString(this.termString.replaceAll("x", `(${x})`))
}
numericToStringResult(y) {
const maxPositiveNumber = 10 ** (NUM_CELLS_PER_ROW - 1) - 1
const maxNegativeNumber = -(10 ** (NUM_CELLS_PER_ROW - 2) - 1)
if (y > maxPositiveNumber) {
return ">" + maxPositiveNumber
} else if (y < maxNegativeNumber) {
return "<" + maxNegativeNumber
} else {
let yString = null
for (let n = 0; n <= NUM_CELLS_PER_ROW; n++) {
yString = (y >= 0 && y < 10) ? ("0" + y.toFixed(n)) : y.toFixed(n)
if (yString.length == NUM_CELLS_PER_ROW - 1) {
break
} else if (yString.length >= NUM_CELLS_PER_ROW) {
yString = yString.slice(0, NUM_CELLS_PER_ROW - 1)
}
}
if (parseFloat(yString) == y) {
return `=${yString}`
} else {
return `≈${yString}`
}
}
}
computeStringResultAt(x) {
let y = null
try {
y = this.computeAt(x)
} catch (e) {
if (e instanceof NumberParserError) {
return "undefined".slice(0, NUM_CELLS_PER_ROW).padStart(NUM_CELLS_PER_ROW, " ")
} else {
throw e
}
}
return this.numericToStringResult(y)
}
}
class Vector2d {
constructor(x, y) {
this.x = x
this.y = y
}
static get zero() {
return new Vector2d(0, 0)
}
static fromFunc(f) {
return new Vector2d(f(0), f(1))
}
copy() {
return new Vector2d(this.x, this.y)
}
add(v) {
return new Vector2d(this.x + v.x, this.y + v.y)
}
iadd(v) {
this.x += v.x
this.y += v.y
}
sub(v) {
return new Vector2d(this.x - v.x, this.y - v.y)
}
isub(v) {
this.x -= v.x
this.y -= v.y
}
mul(v) {
return new Vector2d(this.x * v.x, this.y * v.y)
}
imul(v) {
this.x *= v.x
this.y *= v.y
}
div(v) {
return new Vector2d(this.x / v.x, this.y / v.y)
}
idiv(v) {
this.x /= v.x
this.y /= v.y
}
get length() {
return Math.sqrt(this.x * this.x + this.y * this.y)
}
get normalized() {
let m = this.length
return new Vector2d(this.x / m, this.y / m)
}
scale(x) {
return new Vector2d(this.x * x, this.y * x)
}
lerp(v, t) {
let delta = v.sub(this)
return this.add(delta.scale(t))
}
dot(v) {
return this.x * v.x + this.y * v.y
}
iscale(x) {
this.x *= x
this.y *= x
}
distance(v) {
return this.sub(v).length
}
cross(v) {
return this.x * v.y - this.y * v.x
}
round() {
return new Vector2d(Math.round(this.x), Math.round(this.y))
}
static fromAngle(angle) {
return new Vector2d(Math.cos(angle), Math.sin(angle))
}
static fromPolar(mag, angle) {
return new Vector2d(mag * Math.cos(angle), mag * Math.sin(angle))
}
static fromArray(arr) {
return new Vector2d(arr[0], arr[1])
}
set(x, y) {
if (x instanceof Vector2d && y == undefined) {
this.x = x.x
this.y = x.y
} else {
this.x = x
this.y = y
}
}
addX(x) {
return new Vector2d(this.x + x, this.y)
}
addY(y) {
return new Vector2d(this.x, this.y + y)
}
rotate(angle) {
let x = this.x * Math.cos(angle) - this.y * Math.sin(angle)
let y = this.x * Math.sin(angle) + this.y * Math.cos(angle)
return new Vector2d(x, y)
}
irotate(angle) {
let x = this.x * Math.cos(angle) - this.y * Math.sin(angle)
let y = this.x * Math.sin(angle) + this.y * Math.cos(angle)
this.x = x
this.y = y
}
static random() {
let direction = Math.random() * Math.PI * 2
return Vector2d.fromAngle(direction)
}
get angle() {
return Math.atan2(this.y, this.x)
}
angleDifference(v) {
return angleDifference(this.angle, v.angle)
}
angleTo(v) {
return Math.atan2(v.y - this.y, v.x - this.x)
}
equals(v) {
return this.x == v.x && this.y == v.y
}
map(f) {
return new Vector2d(f(this.x), f(this.y))
}
product() {
return this.x * this.y
}
get array() {
return [this.x, this.y]
}
get min() {
return Math.min(...this.array)
}
get max() {
return Math.max(...this.array)
}
abs() {
return new Vector2d(Math.abs(this.x), Math.abs(this.y))
}
toArray() {
return [this.x, this.y]
}
static fromEvent(event, element) {
let x = 0, y = 0
if (event.touches && event.touches[0]) {
x = event.touches[0].clientX
y = event.touches[0].clientY
} else if (event.originalEvent && event.originalEvent.changedTouches[0]) {
x = event.originalEvent.changedTouches[0].clientX
y = event.originalEvent.changedTouches[0].clientY
} else if (event.clientX !== undefined && event.clientY !== undefined) {
x = event.clientX
y = event.clientY
} else if (event.changedTouches && event.changedTouches.length > 0) {
x = event.changedTouches[0].clientX
y = event.changedTouches[0].clientY
}
const rect = element.getBoundingClientRect()
return new Vector2d(x - rect.left, y - rect.top)
}
}
class FunctionPlotter {
constructor(canvas, context, viewCentre, viewHeight) {
this.canvas = canvas
this.context = context ?? canvas.getContext("2d")
this.viewCentre = viewCentre ?? new Vector2d(0, 0)
this.viewHeight = viewHeight ?? 5
this.wurzleFunctions = []
this.guessedPoints = []
}
removeAllFunctions() {
this.wurzleFunctions = []
}
get defaultForegroundColor() {
return getComputedStyle(document.body).getPropertyValue("--card-text-color")
}
get defaultBackgroundColor() {
return getComputedStyle(document.body).getPropertyValue("--header-button-background")
}
get viewWidth() {
return this.canvas.width / this.canvas.height * this.viewHeight
}
pointToScreenPos(point) {
const relativePoint = point.sub(this.viewCentre)
return new Vector2d(
(relativePoint.x / (this.viewWidth) + 0.5) * this.canvas.width,
(-relativePoint.y / (this.viewHeight) + 0.5) * this.canvas.height
)
}
screenPosToPoint(screenPos) {
const x = (screenPos.x / this.canvas.width - 0.5) * this.viewWidth
const y = -(screenPos.y / this.canvas.height - 0.5) * this.viewHeight
const relativePoint = new Vector2d(x, y)
return relativePoint.add(this.viewCentre)
}
clear() {
this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
}
drawPoint(point, {atScreenPos=false, radius=5, color="blue",
label=null, labelSize=13, labelColor=null, labelOffset=null,
labelBaseline="top", labelAlign="left"
}={}) {
labelColor ??= this.defaultForegroundColor
this.context.beginPath()
let screenPos = null
if (atScreenPos) {
screenPos = point
} else {
screenPos = this.pointToScreenPos(point)
}
this.context.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2)
this.context.fillStyle = color
this.context.fill()
if (label !== null) {
this.context.fillStyle = labelColor
this.context.textAlign = labelAlign
this.context.textBaseline = labelBaseline
this.context.font = `${labelSize}px monospace`
const labelPos = screenPos.addX(radius).addY(radius)
if (labelOffset !== null) {
labelPos.iadd(labelOffset.scale(labelSize))
}
this.context.fillText(label, screenPos.x + radius, screenPos.y + radius)
}
}
connectPoints(points, {atScreenPos=false, color=null, width=1}={}) {
color ??= this.defaultForegroundColor
this.context.strokeStyle = color
this.context.lineWidth = width
this.context.beginPath()
for (let i = 0; i < points.length; i++) {
const screenPos = atScreenPos ? points[i] : this.pointToScreenPos(points[i])
if (i == 0) {
this.context.moveTo(screenPos.x, screenPos.y)
} else {
this.context.lineTo(screenPos.x, screenPos.y)
}
}
this.context.stroke()
}
drawAxes() {
const minXY = this.screenPosToPoint(new Vector2d(0, this.canvas.height))
const maxXY = this.screenPosToPoint(new Vector2d(this.canvas.width, 0))
this.connectPoints([
new Vector2d(Math.floor(minXY.x) - 1, 0),
new Vector2d(Math.ceil(maxXY.x) + 1, 0)
])
this.connectPoints([
new Vector2d(0, Math.floor(minXY.y) - 1),
new Vector2d(0, Math.ceil(maxXY.y) + 1)
])
const pinStyling = {color: this.defaultForegroundColor, radius: 3}
let numTicksVisible = Math.max(
Math.ceil(maxXY.x) - Math.floor(minXY.x),
Math.ceil(maxXY.y) - Math.floor(minXY.y)
) * 10
let stepSize = 0.1
let i = 0
while (numTicksVisible > 20) {
const factor = (i % 2 == 0) ? 2 : 5
stepSize *= factor
numTicksVisible /= factor
i++
}
let startX = Math.floor(minXY.x)
startX -= startX % stepSize
for (let x = startX; x <= Math.ceil(maxXY.x); x += stepSize) {
if (x == 0) continue
this.drawPoint(new Vector2d(x, 0), {label: Math.round(x * 10) / 10, ...pinStyling})
}
let startY = Math.floor(minXY.y)
startY -= startY % stepSize
for (let y = startY; y <= Math.ceil(maxXY.y); y += stepSize) {
this.drawPoint(new Vector2d(0, y), {label: Math.round(y * 10) / 10, ...pinStyling})
}
}
plot(wurzleFunction, color="blue") {
const points = Array.from({length: this.canvas.width})
.map((_, i) => this.screenPosToPoint(new Vector2d(i, 0)).x)
.map(x => {
try {
const y = wurzleFunction.computeAt(x)
if (isNaN(y)) {
throw new Error("Value may not be NaN")
}
return new Vector2d(x, y)
} catch {
return null
}
})
const maxDelta = 10
let drewAtLeastOnePoint = false
for (let i = 1; i < points.length; i++) {
const [p1, p2] = [points[i - 1], points[i]]
if (p1 === null || p2 === null) {
continue
}
if (p1.distance(p2) < maxDelta) {
this.connectPoints([p1, p2], {color})
drewAtLeastOnePoint = true
}
}
return drewAtLeastOnePoint
}
addFunction(wurzleFunction) {
this.wurzleFunctions.push(wurzleFunction)
}
removeFunction(wurzleFunction) {
this.wurzleFunctions = this.wurzleFunctions.filter(f => f.termString != wurzleFunction.termString)
}
makeInteractive() {
const redraw = () => {
this.canvas.width = this.canvas.clientWidth
this.canvas.height = this.canvas.clientHeight
this.clear()
this.drawAxes()
let drewAtLeastOnePoint = false
for (const func of this.wurzleFunctions) {
if (this.plot(func)) {
drewAtLeastOnePoint = true
}
}
for (let i = 0; i < this.guessedPoints.length; i++) {
this.drawPoint(this.guessedPoints[i])
}
return drewAtLeastOnePoint
}
this.canvas.addEventListener("wheel", event => {
this.viewHeight *= event.deltaY / 1000 + 1
event.preventDefault()
redraw()
})
let dragPoint = null
let dragStartViewCentre = null
const mousedown = event => {
dragPoint = this.screenPosToPoint(Vector2d.fromEvent(event, this.canvas))
dragStartViewCentre = this.viewCentre.copy()
}
const mousemove = event => {
if (!dragPoint) {
return
}
let temp = this.viewCentre.copy()
this.viewCentre = dragStartViewCentre
const delta = this.screenPosToPoint(Vector2d.fromEvent(event, this.canvas)).sub(dragPoint)
this.viewCentre = temp.copy()
event.preventDefault()
this.viewCentre = dragStartViewCentre.sub(delta)
redraw()
}
const mouseup = event => {
dragPoint = null
dragStartViewCentre = null
}
this.canvas.addEventListener("mousedown", mousedown)
this.canvas.addEventListener("mousemove", mousemove)
this.canvas.addEventListener("mouseup", mouseup)
this.canvas.addEventListener("touchstart", mousedown)
this.canvas.addEventListener("touchmove", mousemove)
this.canvas.addEventListener("touchend", mouseup)
window.addEventListener("resize", redraw)
redraw()
return {redraw}
}
}
function weightedRandomChoice(items, weights) {
console.assert(items.length == weights.length)
const sum = weights.reduce((p, c) => p + c, 0)
let r = Math.random() * sum
for (let i = 0; i < items.length; i++) {
r -= weights[i]
if (r <= 0) {
return items[i]
}
}
}
class FunctionGenerator {
generate() {
const functionTypes = {
"polynomial": 3,
"exponential": 2,
"trigonometric": 1,
"inverse-trigonometric": 1 / 3,
"radical": 2,
"rational": 1,
"abs": 1
}
const randomIntegerCoefficient = () => weightedRandomChoice(
[-5, -4, -3, -2, -1, 1, 2, 3, 4, 5],
[ 1,  1,  1,  2,  6, 8, 5, 1, 1, 1]
)
const chosenType = weightedRandomChoice(Object.keys(functionTypes), Object.values(functionTypes))
let termString = ""
if (chosenType == "polynomial") {
const degree = weightedRandomChoice([1, 2, 3], [2, 3, 1])
const coefficients = [0, 0, 0, 0]
const randomiseCoefficients = () => {
for (let i = 0; i <= degree; i++) {
if (i != 0 && i != degree && Math.random() < 1 / 3) {
coefficients[i] = 0
} else {
coefficients[i] = randomIntegerCoefficient()
}
}
}
const hasRealRoot = () => {
const [d, c, b, a] = coefficients
if (a != 0) {
return true
}
if (b != 0) {
return (c * c - 4 * b * d) >= 0
}
if (c != 0) {
return true
}
return d == 0
}
randomiseCoefficients()
while (!hasRealRoot()) {
randomiseCoefficients()
}
for (let d = coefficients.length - 1; d >= 0; d--) {
const coefficient = coefficients[d]
if (coefficient == 0) {
continue
}
let xStr = `x^${d}`
if (d == 0) {
termString += `${coefficient}+`
continue
} else if (d == 1) {
xStr = `x`
}
if (coefficient == 1) {
termString += `${xStr}+`
} else if (coefficient == -1) {
termString += `-${xStr}+`
} else {
termString += `${coefficient}*${xStr}+`
}
}
termString = termString.slice(0, -1)
}
else if (chosenType == "exponential") {
const base = weightedRandomChoice(["2", "e", "3"], [6, 7, 1])
const a = 1 // randomIntegerCoefficient()
const b = randomIntegerCoefficient()
let c = randomIntegerCoefficient()
while (Math.abs(a) == Math.abs(c)) {
c = randomIntegerCoefficient()
}
if (Math.sign(a) == Math.sign(c)) {
c *= -1
}
if (a == 1) {
} else if (a == -1) {
termString += "-"
} else {
termString += `${a}*`
}
termString += `${base}^`
if (b == 1) {
termString += "x"
} else if (b == -1) {
termString += "(-x)"
} else {
termString += `(${b}*x)`
}
termString += `+${c}`
}
else if (chosenType == "trigonometric" || chosenType == "radical" || chosenType == "abs") {
let f = weightedRandomChoice(["sin", "cos", "tan"], [2, 2, 3])
let a = randomIntegerCoefficient()
let b = 1 // randomIntegerCoefficient()
let c = randomIntegerCoefficient()
let d = randomIntegerCoefficient()
if (chosenType == "radical") {
f = "sqrt"
if (Math.sign(a) == Math.sign(d)) {
d *= -1
}
} else if (chosenType == "abs") {
f = "abs"
if (Math.sign(a) == Math.sign(d)) {
d *= -1
}
}
if (f == "cos") {
b = Math.abs(b)
}
while ((f == "sin" || f == "cos") && Math.abs(a) < Math.abs(d)) {
a = randomIntegerCoefficient()
d = randomIntegerCoefficient()
}
if (a == 1) {
} else if (a == -1) {
termString += `-`
} else {
termString += `${a}*`
}
termString += `${f}(`
if (b == 1) {
termString += "x+"
} else if (b == -1) {
termString += "-x+"
} else {
termString += `${b}*x+`
}
termString += `${c})+${d}`
}
else if (chosenType == "inverse-trigonometric") {
let a = randomIntegerCoefficient()
let b = randomIntegerCoefficient() * 2 + 1
if (a == 1) {
} else if (a == -1) {
termString += "-"
} else {
termString += `${a}*`
}
termString += `arctan(x+${b})`
}
else if (chosenType == "rational") {
let a = randomIntegerCoefficient()
let b = weightedRandomChoice([1, 2], [5, 1])
let c = randomIntegerCoefficient()
if (Math.sign(a) == Math.sign(c)) {
c *= -1
}
termString += `${a}/`
if (b == 1) {
termString += "x"
} else {
termString += `(x^${b})`
}
termString += `+${c}`
}
else {
throw new Error("Unknown function type: " + chosenType)
}
termString = termString.replaceAll("+-", "-")
return termString
}
}
const functionGenerator = new FunctionGenerator()
const WurzleGameState = {
Playing: "playing",
Results: "results"
}
let hasSentApiFinishUpdate = false
class WurzleGame {
constructor(cellsContainer, wurzleFunction) {
this.cellsContainer = cellsContainer
this.wurzleFunction = wurzleFunction
this.guesses = []
this.state = WurzleGameState.Playing
}
addHtmlRow(stringInput, stringOutput) {
/*
<div class="wurzle-grid-row">
<div class="wurzle-grid-row-header">
f(0.123)
</div>
<div class="wurzle-grid-row-cells">
<div class="wurzle-grid-cell">&lt;</div>
<div class="wurzle-grid-cell">-</div>
<div class="wurzle-grid-cell">9</div>
<div class="wurzle-grid-cell">9</div>
<div class="wurzle-grid-cell">9</div>
</div>
</div>
*/
const row = document.createElement("div")
row.classList.add("wurzle-grid-row")
const header = document.createElement("div")
header.classList.add("wurzle-grid-row-header")
const b = document.createElement("span")
const span = document.createElement("b")
b.textContent = `(${this.guesses.length}/${NUM_MAX_GUESSES}) `
span.textContent = `f(${stringInput})`
header.appendChild(b)
header.appendChild(span)
const cells = document.createElement("div")
cells.classList.add("wurzle-grid-row-cells")
let won = true
for (let i = 0; i < NUM_CELLS_PER_ROW; i++) {
const cell = document.createElement("div")
cell.classList.add("wurzle-grid-cell")
if (i < stringOutput.length) {
cell.textContent = stringOutput[i]
} else {
cell.textContent = "_"
}
cells.appendChild(cell)
cell.style.transform = "scaleY(-1)"
cell.style.color = CELL_HIDDEN_BACKGROUND_COLOR
cell.style.backgroundColor = CELL_HIDDEN_BACKGROUND_COLOR
let cellColor = (
stringOutput[i] == "0"
|| (i < NUM_CELLS_PER_ROW - 1 && stringOutput[i] == "." && stringOutput[i + 1] == "0")
|| (i < NUM_CELLS_PER_ROW - 1 && stringOutput[i] == "=" && stringOutput[i + 1] == "0")
|| (i < NUM_CELLS_PER_ROW - 2 && stringOutput[i] == "=" && stringOutput[i + 1] == "-" && stringOutput[i + 2] == "0")
|| (i < NUM_CELLS_PER_ROW - 2 && stringOutput[i] == "≈" && stringOutput[i + 1] == "-" && stringOutput[i + 2] == "0")
|| (i < NUM_CELLS_PER_ROW - 1 && stringOutput[i] == "≈" && stringOutput[i + 1] == "0")
|| (i < NUM_CELLS_PER_ROW - 1 && stringOutput[i] == "-" && stringOutput[i + 1] == "0")
|| (i == NUM_CELLS_PER_ROW - 1 && stringOutput[i] == ".")
) ? CELL_GOOD_BACKGROUND_COLOR : CELL_BAD_BACKGROUND_COLOR
const cellForegroundColor = cellColor == CELL_GOOD_BACKGROUND_COLOR ? CELL_GOOD_FOREGROUND_COLOR : CELL_BAD_FOREGROUND_COLOR
if (cellColor != CELL_GOOD_BACKGROUND_COLOR) {
won = false
}
setTimeout(() => {
cell.animate([
{transform: "scaleY(-1)", backgroundColor: CELL_HIDDEN_BACKGROUND_COLOR, color: CELL_HIDDEN_BACKGROUND_COLOR},
{transform: "scaleY(0)", backgroundColor: cellColor, color: cellForegroundColor},
{transform: "scaleY(1)", backgroundColor: cellColor, color: cellForegroundColor}
], {
duration: 500,
fill: "forwards",
easing: "ease-out"
})
}, NUM_CELLS_PER_ROW * 200 - i * 200)
}
row.appendChild(header)
row.appendChild(cells)
this.cellsContainer.appendChild(row)
return won
}
makeResultsString(won=true) {
const characterEmojiMap = {
"0": "0️⃣", "1": "1️⃣", "2": "2️⃣",
"3": "3️⃣", "4": "4️⃣", "5": "5️⃣",
"6": "6️⃣", "7": "7️⃣", "8": "8️⃣",
"9": "9️⃣", ".": "⏺", "-": "⛔",
"u": "*️⃣", "n": "*️⃣", "d": "*️⃣", "e": "*️⃣", "f": "*️⃣"
}
const guessIndicator = (!won) ? "x" : this.guesses.length
let str = `Wurzle #${wurzleNumero} ${guessIndicator}/${NUM_MAX_GUESSES}\n`
for (const guess of this.guesses) {
for (const char of guess.output) {
if (characterEmojiMap[char]) {
str += characterEmojiMap[char]
}
}
str += "\n"
}
str += `recmaths.ch/wurzle`
return str
}
endgame() {
fillDataElements("num-guesses", this.guesses.length)
showPopup()
}
win() {
this.endgame()
wurzleGoodResultsContainer.style.display = "block"
wurzleBadResultsContainer.style.display = "none"
if (!hasSentApiFinishUpdate) {
hasSentApiFinishUpdate = true
fetch("https://www.noel-friedrich.de/wurzle-api/success.php")
}
this.resultString = this.makeResultsString(true)
}
lose() {
this.endgame()
wurzleGoodResultsContainer.style.display = "none"
wurzleBadResultsContainer.style.display = "block"
if (!hasSentApiFinishUpdate) {
hasSentApiFinishUpdate = true
fetch("https://www.noel-friedrich.de/wurzle-api/finish.php")
}
this.resultString = this.makeResultsString(false)
}
inputNumber(number) {
if (this.state !== WurzleGameState.Playing) {
return false
}
const stringInput = number.toString()
const stringOutput = this.wurzleFunction.computeStringResultAt(number)
this.guesses.push({input: stringInput, output: stringOutput})
const won = this.addHtmlRow(stringInput, stringOutput)
if (won) {
setTimeout(() => this.win(), 1700)
this.state = WurzleGameState.Results
} else if (this.guesses.length >= NUM_MAX_GUESSES) {
setTimeout(() => this.lose(), 1700)
this.state = WurzleGameState.Results
}
return won
}
}
class WurzleLoader {
static wurzles = null
static wurzleApi = "https://www.noel-friedrich.de/wurzle-api/get_wurzles.php"
static dateStringToDate(dateString) {
const [day, monthPlusOne, year] = dateString.split(".").map(s => parseInt(s))
return new Date(Date.UTC(year, monthPlusOne - 1, day))
}
static async loadWurzles() {
const response = await fetch(this.wurzleApi)
const jsonData = await response.json()
this.wurzles = jsonData.map(o => ({
dateString: o.date,
termString: o.term,
author: o.author,
date: this.dateStringToDate(o.date)
}))
this.wurzles.sort((a, b) => a.date - b.date)
for (let i = 0; i < this.wurzles.length; i++) {
this.wurzles[i].numero = i + 1
}
for (const wurzle of this.wurzles) {
const [day, month, year] = wurzle.dateString.split(".").map(s => parseInt(s))
const today = new Date()
if (today.getDate() == day && today.getMonth() == month - 1 && today.getFullYear() == year) {
continue
}
calendarWidget.addClickableDay(day, month, year, {
title: `Play Wurzle#${wurzle.numero}`,
func: () => location.search = `w=${wurzle.numero}`
})
}
calendarWidget.update()
}
static async getAllWurzles() {
if (this.wurzles === null) {
await this.loadWurzles()
}
return this.wurzles
}
static async getWurzleNumero(numero) {
if (this.wurzles === null) {
await this.loadWurzles()
}
return this.wurzles.find(w => w.numero == numero)
}
static async getLatestWurzle() {
if (this.wurzles === null) {
await this.loadWurzles()
}
return this.wurzles[this.wurzles.length - 1]
}
}
const urlParams = new URLSearchParams(location.search)
let trainingModeActive = urlParams.has("training")
let oldWurzleActive = urlParams.has("w") && !isNaN(urlParams.get("w"))
let oldWurzleId = parseInt(urlParams.get("w"))
let testWurzleActive = urlParams.has("t")
let testWurzleFunctionString = urlParams.get("t")
if (trainingModeActive + oldWurzleActive + testWurzleActive > 1) {
location.search = ""
}
let f = null
let wurzleGame = null
let secretFunctionString = null
let wurzleNumero = -1
async function init() {
if (trainingModeActive) {
revealElements("trainingmode")
enableTrainingModeButton.style.display = "none"
secretFunctionString = functionGenerator.generate()
WurzleLoader.loadWurzles()
revealElements("playtodayswurzle")
fillDataElements("wurzle-author", "Random Generator")
} else if (testWurzleActive) {
try {
secretFunctionString = atob(testWurzleFunctionString)
revealElements("testmode")
} catch (e) {
if (e instanceof NumberParserError) {
alert("Invalid Function String. Aborting.")
} else {
alert(e.message)
}
location.search = ""
}
revealElements("playtodayswurzle")
disableTrainingModeButton.style.display = "none"
fillDataElements("wurzle-author", "Anonymous Creator")
} else {
let wurzle = null
revealElements("loading")
try {
if (oldWurzleActive) {
wurzle = await WurzleLoader.getWurzleNumero(oldWurzleId)
if (!wurzle) {
location.search = ""
} else {
revealElements("oldwurzle")
revealElements("playtodayswurzle")
}
} else {
wurzle = await WurzleLoader.getLatestWurzle()
}
} catch(e) {
revealElements("failedtoload")
hideElements("loading")
throw e
}
hideElements("loading")
secretFunctionString = wurzle.termString
wurzleNumero = wurzle.numero
disableTrainingModeButton.style.display = "none"
fillDataElements("wurzle-date", wurzle.dateString)
fillDataElements("wurzle-author", wurzle.author)
}
f = new WurzleFunction(secretFunctionString)
wurzleGame = new WurzleGame(wurzleGridContainer, f)
fillDataElements("secret-function", "f(x) = " + "#".repeat(6))
fillDataElements("wurzle-numero", wurzleNumero)
}
wurzleInput.addEventListener("input", () => {
wurzleInput.value = wurzleInput.value.toLowerCase()
if (wurzleInput.value.length > 18) {
wurzleInput.value = wurzleInput.value.slice(0, 18)
}
try {
if (wurzleInput.value.length > 0) {
evaluateNumberString(wurzleInput.value)
}
wurzleInput.style.color = "var(--cell-foreground-color)"
} catch {
wurzleInput.style.color = "var(--error-color)"
}
})
let hasSentApiInitUpdate = false
wurzleSubmitButton.addEventListener("click", () => {
try {
const x = evaluateNumberString(wurzleInput.value)
wurzleGame.inputNumber(x)
wurzleInput.value = ""
if (!hasSentApiInitUpdate) {
hasSentApiInitUpdate = true
fetch("https://www.noel-friedrich.de/wurzle-api/init.php")
}
} catch {}
})
wurzleInput.addEventListener("keydown", event => {
if (event.key == "Enter") {
wurzleSubmitButton.click()
}
})
for (const button of revealFunctionButtons) {
button.addEventListener("click", () => {
fillDataElements("secret-function", "f(x) = " + f.termString)
const canvas = document.createElement("canvas")
canvas.style.width = "100%"
canvas.style.aspectRatio = "16 / 9"
button.replaceWith(canvas)
const plotter = new FunctionPlotter(canvas)
plotter.viewCentre = new Vector2d(parseFloat(wurzleGame.guesses.slice(-1)[0].input), 0)
plotter.viewHeight = 12
plotter.addFunction(f)
plotter.guessedPoints = wurzleGame.guesses.map(({input}) => {
try {
const x = parseFloat(input)
const y = f.computeAt(x)
return new Vector2d(x, y)
} catch {
return null
}
}).filter(g => g !== null)
const { redraw } = plotter.makeInteractive()
redrawActivePlot = redraw
for (const btn of revealFunctionButtons) {
btn.remove()
}
})
}
wurzleClosePopupButton.addEventListener("click", hidePopup)
for (const button of shareResultsButtons) {
button.addEventListener("click", async () => {
const shareText = wurzleGame.resultString
const header = shareText.split("\n")[0]
if (navigator.share) {
navigator.share({
title: header,
text: shareText
})
} else {
await navigator.clipboard.writeText(shareText)
alert("Copied Text to Clipboard!")
}
})
if (trainingModeActive) {
button.disabled = true
}
}
enableTrainingModeButton.addEventListener("click", () => {
location.search = "training"
})
disableTrainingModeButton.addEventListener("click", () => {
location.search = ""
})
showResultsButton.addEventListener("click", () => {
if (wurzleGame.state != WurzleGameState.Results) {
return
}
showPopup()
})
init()
