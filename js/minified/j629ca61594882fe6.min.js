class Vector2d {
constructor(x, y) {
this.x = x
this.y = y
}
static get zero() {
return new Vector2d(0, 0)
}
static fromFunc(f) {
return new Vector2d(f(0), f(1))
}
copy() {
return new Vector2d(this.x, this.y)
}
add(v) {
return new Vector2d(this.x + v.x, this.y + v.y)
}
iadd(v) {
this.x += v.x
this.y += v.y
}
sub(v) {
return new Vector2d(this.x - v.x, this.y - v.y)
}
isub(v) {
this.x -= v.x
this.y -= v.y
}
mul(v) {
return new Vector2d(this.x * v.x, this.y * v.y)
}
imul(v) {
this.x *= v.x
this.y *= v.y
}
div(v) {
return new Vector2d(this.x / v.x, this.y / v.y)
}
idiv(v) {
this.x /= v.x
this.y /= v.y
}
get length() {
return Math.sqrt(this.x * this.x + this.y * this.y)
}
get normalized() {
let m = this.length
return new Vector2d(this.x / m, this.y / m)
}
scale(x) {
return new Vector2d(this.x * x, this.y * x)
}
lerp(v, t) {
let delta = v.sub(this)
return this.add(delta.scale(t))
}
dot(v) {
return this.x * v.x + this.y * v.y
}
iscale(x) {
this.x *= x
this.y *= x
}
distance(v) {
return this.sub(v).length
}
cross(v) {
return this.x * v.y - this.y * v.x
}
round() {
return new Vector2d(Math.round(this.x), Math.round(this.y))
}
static fromAngle(angle) {
return new Vector2d(Math.cos(angle), Math.sin(angle))
}
static fromPolar(mag, angle) {
return new Vector2d(mag * Math.cos(angle), mag * Math.sin(angle))
}
static fromArray(arr) {
return new Vector2d(arr[0], arr[1])
}
set(x, y) {
if (x instanceof Vector2d && y == undefined) {
this.x = x.x
this.y = x.y
} else {
this.x = x
this.y = y
}
}
addX(x) {
return new Vector2d(this.x + x, this.y)
}
addY(y) {
return new Vector2d(this.x, this.y + y)
}
rotate(angle) {
let x = this.x * Math.cos(angle) - this.y * Math.sin(angle)
let y = this.x * Math.sin(angle) + this.y * Math.cos(angle)
return new Vector2d(x, y)
}
irotate(angle) {
let x = this.x * Math.cos(angle) - this.y * Math.sin(angle)
let y = this.x * Math.sin(angle) + this.y * Math.cos(angle)
this.x = x
this.y = y
}
static random() {
let direction = Math.random() * Math.PI * 2
return Vector2d.fromAngle(direction)
}
get angle() {
return Math.atan2(this.y, this.x)
}
angleDifference(v) {
return angleDifference(this.angle, v.angle)
}
angleTo(v) {
return Math.atan2(v.y - this.y, v.x - this.x)
}
equals(v) {
return this.x == v.x && this.y == v.y
}
map(f) {
return new Vector2d(f(this.x), f(this.y))
}
product() {
return this.x * this.y
}
get array() {
return [this.x, this.y]
}
get min() {
return Math.min(...this.array)
}
get max() {
return Math.max(...this.array)
}
abs() {
return new Vector2d(Math.abs(this.x), Math.abs(this.y))
}
toArray() {
return [this.x, this.y]
}
static fromEvent(event, element) {
let x = 0, y = 0
if (event.touches && event.touches[0]) {
x = event.touches[0].clientX
y = event.touches[0].clientY
} else if (event.originalEvent && event.originalEvent.changedTouches[0]) {
x = event.originalEvent.changedTouches[0].clientX
y = event.originalEvent.changedTouches[0].clientY
} else if (event.clientX !== undefined && event.clientY !== undefined) {
x = event.clientX
y = event.clientY
} else if (event.changedTouches && event.changedTouches.length > 0) {
x = event.changedTouches[0].clientX
y = event.changedTouches[0].clientY
}
const rect = element.getBoundingClientRect()
return new Vector2d(x - rect.left, y - rect.top)
}
}
function drawPathOnBackground(cellGrid, pathVectors) {
const positionOfCell = cellElement => {
const cellRect = cellElement.getBoundingClientRect()
const canvasRect = pathMathGridBackground.getBoundingClientRect()
return new Vector2d(
cellRect.left - canvasRect.left + cellRect.width / 2,
cellRect.top - canvasRect.top + cellRect.height / 2
)
}
pathMathGridBackground.width = pathMathGridBackground.clientWidth
pathMathGridBackground.height = pathMathGridBackground.clientHeight
context.clearRect(0, 0, pathMathGridBackground.width, pathMathGridBackground.height)
context.strokeStyle = getComputedStyle(pathMathGlobal).getPropertyValue("--mark-color")
context.lineWidth = cellGrid[0][0].clientWidth * 0.3
const fontSize = cellGrid[0][0].clientWidth * 0.2
context.font = `${fontSize}px Arial`
context.textBaseline = "middle"
context.textAlign = "center"
context.fillStyle = "green"
for (let i = 1; i < pathVectors.length; i++) {
const cell1 = cellGrid[pathVectors[i - 1].y][pathVectors[i - 1].x]
const cell2 = cellGrid[pathVectors[i].y][pathVectors[i].x]
const p1 = positionOfCell(cell1)
const p2 = positionOfCell(cell2)
context.beginPath()
context.moveTo(p1.x, p1.y)
context.lineTo(p2.x, p2.y)
context.stroke()
const delta = pathVectors[i].sub(pathVectors[i - 1])
const manhattanLength = Math.abs(delta.x) + Math.abs(delta.y)
const isMultiplication = manhattanLength == 2
const operationStr = isMultiplication ? "×" : "±"
const averagePos = p1.lerp(p2, 0.5)
context.fillText(operationStr, averagePos.x, averagePos.y)
}
}
class PathMathGame {
constructor(numberMatrix, goalNumber) {
this.numberMatrix = numberMatrix
this.goalNumber = goalNumber
this.cellGrid = []
}
get size() {
return new Vector2d(this.numberMatrix[0].length, this.numberMatrix.length)
}
initHtml() {
pathMathGrid.style.setProperty("--grid-size-x", this.size.x)
pathMathGrid.style.setProperty("--grid-size-y", this.size.y)
let lastCell = null
this.cellGrid = []
for (let i = 0; i < this.numberMatrix.length; i++) {
const cellRow = []
for (let j = 0; j < this.numberMatrix[i].length; j++) {
const cellElement = document.createElement("div")
cellElement.classList.add("pathmath-cell")
cellElement.textContent = this.numberMatrix[i][j]
cellElement.dataset.x = j
cellElement.dataset.y = i
pathMathGrid.appendChild(cellElement)
lastCell = cellElement
cellRow.push(cellElement)
}
this.cellGrid.push(cellRow)
}
goalOutput.textContent = this.goalNumber
const updateGridSize = () => pathMathGlobal.style.setProperty("--grid-cell-size-px", `${lastCell.clientWidth}px`)
addEventListener("resize", updateGridSize)
updateGridSize()
}
submitNumberPath(numbers, positionDeltas) {
const MovementType = {
Addition: 0,
Multiplication: 1
}
const movements = positionDeltas.map(delta => {
const manhattanLength = Math.abs(delta.x) + Math.abs(delta.y)
if (manhattanLength == 2) {
return MovementType.Multiplication
} else {
return MovementType.Addition
}
})
const possibleResults = new Set()
function recurse(currValue, numbersLeft, movementsLeft) {
if (numbersLeft.length == 0) {
possibleResults.add(currValue)
return
}
const number = numbersLeft.shift()
const movement = movementsLeft.shift()
if (movement == MovementType.Addition) {
recurse(currValue + number, numbersLeft.slice(), movementsLeft.slice())
recurse(currValue - number, numbersLeft.slice(), movementsLeft.slice())
} else {
recurse(currValue * number, numbersLeft.slice(), movementsLeft.slice())
}
}
recurse(numbers[0], numbers.slice(1), movements)
if (possibleResults.has(this.goalNumber)) {
alert("You won!")
}
}
makeInteractive() {
let isDragging = false
let currPath = []
let currNumbers = []
const canAddToPath = v => {
if (currPath.length == 0) {
return true
}
let i = 0
for (const other of currPath) {
if (other.x == v.x && other.y == v.y) {
currPath.splice(i + 1, currPath.length)
return false
}
i++
}
const lastPathVector = currPath[currPath.length - 1]
for (let x = -1; x <= 1; x++) {
for (let y = -1; y <= 1; y++) {
if (x + v.x == lastPathVector.x && y + v.y == lastPathVector.y) {
if (x == 0 && y == 0) {
return false
} else {
return true
}
}
}
}
return false
}
const globalMouseup = () => {
const positionDeltas = currPath.slice(1).map((p, i) => p.sub(currPath[i]))
this.submitNumberPath(currNumbers, positionDeltas)
currPath = []
currNumbers = []
isDragging = false
redrawPath()
}
const redrawPath = () => {
for (const cell of this.cellGrid.flat()) {
cell.classList.remove("pathstart")
cell.classList.remove("inpath")
}
for (const v of currPath) {
this.cellGrid[v.y][v.x].classList.add("inpath")
}
if (currPath.length > 0) {
const v = currPath[0]
this.cellGrid[v.y][v.x].classList.add("pathstart")
}
drawPathOnBackground(this.cellGrid, currPath)
}
addEventListener("mouseup", globalMouseup)
addEventListener("touchend", globalMouseup)
const infoGrid = JSON.parse(JSON.stringify(this.numberMatrix))
for (let x = 0; x < this.size.x; x++) {
for (let y = 0; y < this.size.y; y++) {
const position = new Vector2d(x, y)
const cell = this.cellGrid[y][x]
const num = this.numberMatrix[y][x]
const mousedown = event => {
event.preventDefault()
isDragging = true
if (!canAddToPath(position)) {
redrawPath()
return
}
currPath.push(position)
currNumbers.push(num)
redrawPath()
}
const mousemove = event => {
event.preventDefault()
if (!isDragging || !canAddToPath(position)) {
redrawPath()
return
}
currPath.push(position)
currNumbers.push(num)
redrawPath()
}
const touchmove = event => {
const touch = event.touches[0]
const pageCoords = new Vector2d(touch.clientX, touch.clientY)
const target = document.elementFromPoint(pageCoords.x, pageCoords.y)
if (target.classList.contains("pathmath-cell")) {
const v = new Vector2d(target.dataset.x, target.dataset.y)
infoGrid[v.y][v.x].mousemove(event)
}
}
infoGrid[y][x] = {mousemove, mousedown, touchmove}
cell.addEventListener("mousedown", mousedown)
cell.addEventListener("mousemove", mousemove)
cell.addEventListener("touchstart", mousedown)
cell.addEventListener("touchmove", touchmove)
}
}
}
_copyMatrix(m) {
return m.map(r => r.slice())
}
computeAllPossibleSolutions() {
let recursionCount = 0
const allPossibleValues = new Set()
const allPossibleStrs = new Set()
const numMaps = new Map()
const numCountMap = new Map()
const recurse = (currValue, currX, currY, matrixLeft, str) => {
recursionCount++
allPossibleValues.add(currValue)
numMaps.set(currValue, str)
if (numCountMap.has(currValue)) {
numCountMap.set(currValue, numCountMap.get(currValue) + 1)
} else {
numCountMap.set(currValue, 1)
}
for (let x = 0; x < this.size.x; x++) {
for (let y = 0; y < this.size.y; y++) {
const val = matrixLeft[y][x]
if (val === null) {
continue
}
const maxDistance = Math.max(Math.abs(currX - x), Math.abs(currY - y))
if (maxDistance > 1) {
continue
}
const manhattanDistance = Math.abs(currX - x) + Math.abs(currY - y)
if (manhattanDistance == 1) {
const newMatrix1 = this._copyMatrix(matrixLeft)
const newMatrix2 = this._copyMatrix(matrixLeft)
newMatrix1[y][x] = null
newMatrix2[y][x] = null
recurse(currValue + val, x, y, newMatrix1, `(${str}+${val})`)
recurse(currValue - val, x, y, newMatrix2, `(${str}-${val})`)
} else {
const newMatrix = this._copyMatrix(matrixLeft)
newMatrix[y][x] = null
recurse(currValue * val, x, y, newMatrix, `(${str}*${val})`)
}
}
}
}
for (let x = 0; x < this.size.x; x++) {
for (let y = 0; y < this.size.y; y++) {
const num = this.numberMatrix[y][x]
const matrix = this._copyMatrix(this.numberMatrix)
matrix[y][x] = null
recurse(num, x, y, matrix, `${num}`)
}
}
const sortedPossibleValues = Array.from(allPossibleValues).sort((a, b) => a - b)
window.sortedPossibleValues = sortedPossibleValues
window.allPossibleStrs = allPossibleStrs
console.log(`recursionCount=${recursionCount}`)
console.log(`min value: ${sortedPossibleValues[0]} (${numCountMap.get(sortedPossibleValues[0])} ways)`)
console.log(`min path: ${numMaps.get(sortedPossibleValues[0])}`)
console.log(`max value: ${sortedPossibleValues[sortedPossibleValues.length - 1]} (${numCountMap.get(sortedPossibleValues[sortedPossibleValues.length - 1])} ways)`)
console.log(`max path: ${numMaps.get(sortedPossibleValues[sortedPossibleValues.length - 1])}`)
console.log(`goal number ways: ${numCountMap.get(this.goalNumber)}`)
let mostCommonNumber = null
let mostCommonNumberWays = 0
for (const num of allPossibleValues) {
const numWays = numCountMap.get(num)
if (numWays > mostCommonNumberWays) {
mostCommonNumber = num
mostCommonNumberWays = numWays
}
}
console.log(`most common number: ${mostCommonNumber} (${mostCommonNumberWays} ways)`)
return numCountMap
}
static random(size=new Vector2d(3, 3), range=5) {
const numbers = []
while (numbers.length < size.x * size.y) {
const num = Math.floor((Math.random() * range * 2 + 2) - range - 1)
if (!numbers.includes(num)) {
numbers.push(num)
}
}
const game = new PathMathGame(Array.from({length: size.y}).map((_, i) => Array.from({length: size.x}).map((_, j) => {
return numbers[i * size.x + j]
})))
const countMap = game.computeAllPossibleSolutions()
const allPossibleGoals = Array.from(countMap.keys())
const goalNumber = weightedRandomChoice(allPossibleGoals, allPossibleGoals.map(g => countMap.get(g)))
game.goalNumber = goalNumber
console.log(`possible ways: ${countMap.get(goalNumber)}`)
return game
}
}
const game = PathMathGame.random()
document.body.onload = () => {
game.initHtml()
game.makeInteractive()
}
