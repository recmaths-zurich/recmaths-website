let secretFunctionString = "x^2-x-1"
let wurzleNumero = 1
const wurzleGameContainer = document.getElementById("wurzle-game-container")
const wurzleGridContainer = document.getElementById("wurzle-grid-container")
const wurzleGlobalContainer = document.getElementById("wurzle-global-container")
const wurzleInput = document.getElementById("wurzle-input")
const wurzleSubmitButton = document.getElementById("wurzle-submit-button")
const wurzleInputContainer = document.getElementById("wurzle-input-container")
const wurzleShareContainer = document.getElementById("wurzle-share-container")
const wurzleResultsPopup = document.getElementById("wurzle-results-popup")
const wurzleGoodResultsContainer = document.getElementById("wurzle-good-results-container")
const wurzleBadResultsContainer = document.getElementById("wurzle-bad-results-container")
const wurzlePopupBackground = document.getElementById("wurzle-popup-background")
const wurzleClosePopupButton = document.getElementById("close-popup-button")
const revealFunctionButtons = document.querySelectorAll(".function-reveal-button")
const shareResultsButtons = document.querySelectorAll(".share-results-button")
const enableTrainingModeButton = document.getElementById("enable-training-mode-button")
const disableTrainingModeButton = document.getElementById("disable-training-mode-button")
const NUM_CELLS_PER_ROW = 6
const NUM_MAX_GUESSES = 12
wurzleGameContainer.style.setProperty("--num-cells-per-row", NUM_CELLS_PER_ROW)
function updateCSSCellSize() {
const cell = wurzleGridContainer.querySelector(".wurzle-grid-cell")
if (cell) {
const cellSize = cell.clientWidth
wurzleGameContainer.style.setProperty("--cell-size-px", `${cellSize}px`)
}
}
function fillDataElements(key, value) {
for (const element of document.querySelectorAll(`[data-fill='${key}']`)) {
element.textContent = value
}
}
function revealElements(revealKey) {
for (const element of document.querySelectorAll(`[data-revealwhen='${revealKey}']`)) {
element.style.display = "block"
}
}
fillDataElements("max-num-guesses", NUM_MAX_GUESSES)
window.addEventListener("resize", updateCSSCellSize)
window.addEventListener("DOMContentLoaded", updateCSSCellSize)
const CELL_HIDDEN_BACKGROUND_COLOR = "var(--background)"
const CELL_CARD_BACKGROUND_COLOR = "grey"
const CELL_FOREGROUND_COLOR = "white"
const CELL_GOOD_BACKGROUND_COLOR = "#6aba65"
class NumberParserError extends Error {
constructor(message) {
super(message)
this.name = "NumberParserError"
}
}
function evaluateNumberString(numberString) { //argOption, error
const constants = {
"pi": Math.PI,
"π": Math.PI,
"tau": 2 * Math.PI,
"phi": (1 + Math.sqrt(5)) / 2,
"Φ": (1 + Math.sqrt(5)) / 2,
"goldenratio": (1 + Math.sqrt(5)) / 2,
"e": Math.E,
}
for (const [constant, value] of Object.entries(constants)) {
if (numberString == constant) {
return value
}
}
if (numberString == "inf") {
throw new NumberParserError(`Infinity is not a number`)
}
const decimalRegex = /^[0123456789]+\.[0123456789]+$/
const intRegex = /^[0123456789]+$/
const hexDecimalRegex = /^0x[0123456789abcdef]+\.[0123456789abcdef]+$/
const hexIntRegex = /^0x[0123456789abcdef]+$/
const binDecimalRegex = /^0b[01]+\.[01]+$/
const binIntRegex = /^0b[01]+$/
const scientificRegex = /^\-?[0123456789]+(\.[0123456789]+)?e-?[0123456789]+$/
if (numberString.startsWith("-")) {
return -evaluateNumberString(numberString.slice(1))
}
const allowedFunctions = {
"sqrt": {
compute: n => Math.sqrt(n),
constraints: [
{
if: n => (n < 0),
err: () => new NumberParserError(`sqrt is only defined on [0, inf)`)
}
]
},
"abs":     {compute: n => Math.abs(n)},
"sin":     {compute: n => Math.sin(n)},
"cos":     {compute: n => Math.cos(n)},
"tan":     {compute: n => Math.tan(n)},
"arcsin":  {
compute: n => Math.asin(n),
constraints: [
{
if: n => (n < -1) || (n > 1),
err: () => new NumberParserError(`arcsin is only defined on [-1, 1]`)
}
]
},
"arccos":  {
compute: n => Math.acos(n),
constraints: [
{
if: n => (n < -1) || (n > 1),
err: () => new NumberParserError(`arccos is only defined on [-1, 1]`)
}
]
},
"arctan":  {compute: n => Math.atan(n)},
"sinh":    {compute: n => Math.sinh(n)},
"cosh":    {compute: n => Math.cosh(n)},
"tanh":    {compute: n => Math.tanh(n)},
"arcsinh": {compute: n => Math.asinh(n)},
"arccosh": {
compute: n => Math.acosh(n),
constraints: [
{
if: n => (n < 1),
err: () => new NumberParserError(`arccosh is only defined on [1, inf)`)
}
]
},
"arctanh": {
compute: n => Math.atanh(n),
constraints: [
{
if: n => (n <= -1) || (n >= 1),
err: () => new NumberParserError(`arctanh is only defined on (-1, 1)`)
}
]
},
"": {compute: n => n}
}
for (const [functionStr, func] of Object.entries(allowedFunctions)) {
if (numberString.startsWith(`${functionStr}(`)) {
const numberPart = numberString.slice(functionStr.length + 1, -1)
let openCount = 0
let abortThisExecution = false
for (const char of numberPart) {
if (char == "(") {
openCount++
} else if (char == ")") {
openCount--
}
if (openCount < 0) {
abortThisExecution = true
break
}
}
if (abortThisExecution) {
continue
}
const value = evaluateNumberString(numberPart)
for (const constraint of (func.constraints ?? [])) {
if (constraint.if(value)) {
throw constraint.err()
}
}
return func.compute(value)
}
}
if (intRegex.test(numberString)) {
return parseInt(numberString)
} else if (hexIntRegex.test(numberString)) {
return parseInt(numberString.slice(2), 16)
} else if (binIntRegex.test(numberString)) {
return parseInt(numberString.slice(2), 2)
}
if (decimalRegex.test(numberString)) {
return parseFloat(numberString)
} else if (binDecimalRegex.test(numberString)) {
const [before, after] = numberString.split(".")
const beforeVal = parseInt(before.slice(2), 2)
const afterVal = parseInt(after, 2)
return beforeVal + afterVal / (2 ** after.length)
} else if (hexDecimalRegex.test(numberString)) {
const [before, after] = numberString.split(".")
const beforeVal = parseInt(before.slice(2), 16)
const afterVal = parseInt(after, 16)
return beforeVal + afterVal / (16 ** after.length)
}
if (scientificRegex.test(numberString)) {
let [decimal, exponent] = numberString.split("e")
decimal = parseFloat(decimal)
exponent = parseInt(exponent)
return decimal * (10 ** exponent)
}
const operators = [
["+", (a, b) => a + b],
["-", (a, b) => a - b],
["*", (a, b) => a * b],
["/", (a, b) => a / b],
["^", (a, b) => a ** b],
]
for (const [operatorName, operatorFunc] of operators) {
let currLevel = 0
let foundSplitIndex = null
for (let i = 0; i < numberString.length; i++) {
const char = numberString[i]
if (char == "(") currLevel++
if (char == ")") currLevel--
if (currLevel < 0) {
throw new NumberParserError(`Unbalanced parentheses`)
}
if (char == operatorName && currLevel == 0) {
foundSplitIndex = i
}
}
if (currLevel != 0) {
throw new NumberParserError(`Unbalanced parentheses`)
}
if (foundSplitIndex === null) {
continue
}
const parts = [
numberString.slice(0, foundSplitIndex),
numberString.slice(foundSplitIndex + 1)
]
for (let i = 0; i < 2; i++) {
parts[i] = evaluateNumberString(parts[i])
}
if (parts[1] == 0 && operatorName == "/") {
throw new NumberParserError(`Can't divide by zero`)
}
return operatorFunc(parts[0], parts[1])
}
throw new NumberParserError(`Invalid number`)
}
class WurzleFunction {
constructor(termString) {
this.termString = termString
}
computeAt(x) {
return evaluateNumberString(this.termString.replaceAll("x", `(${x})`))
}
numericToStringResult(y) {
const maxPositiveNumber = 10 ** (NUM_CELLS_PER_ROW - 1) - 1
const maxNegativeNumber = -(10 ** (NUM_CELLS_PER_ROW - 2) - 1)
if (y > maxPositiveNumber) {
return ">" + maxPositiveNumber
} else if (y < maxNegativeNumber) {
return "<" + maxNegativeNumber
} else {
let yString = y.toFixed(NUM_CELLS_PER_ROW)
if (yString.startsWith("-")) {
const lengthBeforePoint = yString.length - NUM_CELLS_PER_ROW - 2
const availableDigits = Math.max(NUM_CELLS_PER_ROW - lengthBeforePoint - 3, 0)
yString = y.toFixed(availableDigits)
} else {
const lengthBeforePoint = yString.length - NUM_CELLS_PER_ROW - 1
const availableDigits = Math.max(NUM_CELLS_PER_ROW - lengthBeforePoint - 2, 0)
yString = y.toFixed(availableDigits)
}
if (yString.length < NUM_CELLS_PER_ROW - 1) {
yString = yString + "."
}
console.assert(yString.length == NUM_CELLS_PER_ROW - 1)
if (parseFloat(yString) == y) {
return `=${yString}`
} else {
return `≈${yString}`
}
}
}
computeStringResultAt(x) {
let y = null
try {
y = this.computeAt(x)
} catch (e) {
if (e instanceof NumberParserError) {
return "undefined".slice(0, NUM_CELLS_PER_ROW).padStart(NUM_CELLS_PER_ROW, " ")
} else {
throw e
}
}
return this.numericToStringResult(y)
}
}
function weightedRandomChoice(items, weights) {
console.assert(items.length == weights.length)
const sum = weights.reduce((p, c) => p + c, 0)
let r = Math.random() * sum
for (let i = 0; i < items.length; i++) {
r -= weights[i]
if (r <= 0) {
return items[i]
}
}
}
class FunctionGenerator {
generate() {
const functionTypes = {
"polynomial": 3,
"exponential": 2,
"trigonometric": 1,
"inverse-trigonometric": 1 / 3,
"radical": 2,
"rational": 1,
"abs": 1
}
const randomIntegerCoefficient = () => weightedRandomChoice(
[-5, -4, -3, -2, -1, 1, 2, 3, 4, 5],
[ 1,  1,  1,  1,  3, 4, 3, 1, 1, 1]
)
const chosenType = weightedRandomChoice(Object.keys(functionTypes), Object.values(functionTypes))
let termString = ""
if (chosenType == "polynomial") {
const degree = weightedRandomChoice([1, 2, 3], [2, 3, 1])
const coefficients = [0, 0, 0, 0]
const randomiseCoefficients = () => {
for (let i = 0; i <= degree; i++) {
if (i != 0 && i != degree && Math.random() < 1 / 3) {
coefficients[i] = 0
} else {
coefficients[i] = randomIntegerCoefficient()
}
}
}
const hasRealRoot = () => {
const [d, c, b, a] = coefficients
if (a != 0) {
return true
}
if (b != 0) {
return (c * c - 4 * b * d) >= 0
}
if (c != 0) {
return true
}
return d == 0
}
randomiseCoefficients()
while (!hasRealRoot()) {
randomiseCoefficients()
}
for (let d = coefficients.length - 1; d >= 0; d--) {
const coefficient = coefficients[d]
if (coefficient == 0) {
continue
}
let xStr = `x^${d}`
if (d == 0) {
termString += `${coefficient}+`
continue
} else if (d == 1) {
xStr = `x`
}
if (coefficient == 1) {
termString += `${xStr}+`
} else if (coefficient == -1) {
termString += `-${xStr}+`
} else {
termString += `${coefficient}*${xStr}+`
}
}
termString = termString.slice(0, -1)
}
else if (chosenType == "exponential") {
const base = weightedRandomChoice(["2", "e", "3"], [1, 3, 1])
const a = randomIntegerCoefficient()
const b = randomIntegerCoefficient()
let c = randomIntegerCoefficient()
while (Math.abs(a) == Math.abs(c)) {
c = randomIntegerCoefficient()
}
if (Math.sign(a) == Math.sign(c)) {
c *= -1
}
if (a == 1) {
} else if (a == -1) {
termString += "-"
} else {
termString += `${a}*`
}
termString += `${base}^`
if (b == 1) {
termString += "x"
} else if (b == -1) {
termString += "(-x)"
} else {
termString += `(${b}*x)`
}
termString += `+${c}`
}
else if (chosenType == "trigonometric" || chosenType == "radical" || chosenType == "abs") {
let f = weightedRandomChoice(["sin", "cos", "tan"], [2, 2, 3])
let a = randomIntegerCoefficient()
let b = randomIntegerCoefficient()
let c = randomIntegerCoefficient()
let d = randomIntegerCoefficient()
if (chosenType == "radical") {
f = "sqrt"
if (Math.sign(a) == Math.sign(d)) {
d *= -1
}
} else if (chosenType == "abs") {
f = "abs"
}
if (f == "cos") {
b = Math.abs(b)
}
while ((f == "sin" || f == "cos") && Math.abs(a) < Math.abs(d)) {
a = randomIntegerCoefficient()
d = randomIntegerCoefficient()
}
if (a == 1) {
} else if (a == -1) {
termString += `-`
} else {
termString += `${a}*`
}
termString += `${f}(`
if (b == 1) {
termString += "x+"
} else if (b == -1) {
termString += "-x+"
} else {
termString += `${b}*x+`
}
termString += `${c})+${d}`
}
else if (chosenType == "inverse-trigonometric") {
let a = randomIntegerCoefficient()
let b = randomIntegerCoefficient() * 2 + 1
if (a == 1) {
} else if (a == -1) {
termString += "-"
} else {
termString += `${a}*`
}
termString += `arctan(x+${b})`
}
else if (chosenType == "rational") {
let a = randomIntegerCoefficient()
let b = weightedRandomChoice([1, 2], [2, 1])
let c = randomIntegerCoefficient()
if (Math.sign(a) == Math.sign(c)) {
c *= -1
}
termString += `${a}/`
if (b == 1) {
termString += "x"
} else {
termString += `(x^${b})`
}
termString += `+${c}`
}
else {
throw new Error("Unknown function type: " + chosenType)
}
termString = termString.replaceAll("+-", "-")
return termString
}
}
const functionGenerator = new FunctionGenerator()
const WurzleGameState = {
Playing: "playing",
Results: "results"
}
class WurzleGame {
constructor(cellsContainer, wurzleFunction) {
this.cellsContainer = cellsContainer
this.wurzleFunction = wurzleFunction
this.guesses = []
this.state = WurzleGameState.Playing
}
addHtmlRow(stringInput, stringOutput) {
/*
<div class="wurzle-grid-row">
<div class="wurzle-grid-row-header">
f(0.123)
</div>
<div class="wurzle-grid-row-cells">
<div class="wurzle-grid-cell">&lt;</div>
<div class="wurzle-grid-cell">-</div>
<div class="wurzle-grid-cell">9</div>
<div class="wurzle-grid-cell">9</div>
<div class="wurzle-grid-cell">9</div>
</div>
</div>
*/
const row = document.createElement("div")
row.classList.add("wurzle-grid-row")
const header = document.createElement("div")
header.classList.add("wurzle-grid-row-header")
header.textContent = `f(${stringInput})`
const cells = document.createElement("div")
cells.classList.add("wurzle-grid-row-cells")
let won = true
for (let i = 0; i < NUM_CELLS_PER_ROW; i++) {
const cell = document.createElement("div")
cell.classList.add("wurzle-grid-cell")
if (i < stringOutput.length) {
cell.textContent = stringOutput[i]
} else {
cell.textContent = "_"
}
cells.appendChild(cell)
cell.style.transform = "scaleY(-1)"
cell.style.color = CELL_HIDDEN_BACKGROUND_COLOR
cell.style.backgroundColor = CELL_HIDDEN_BACKGROUND_COLOR
let cellColor = (
stringOutput[i] == "0"
|| (i < NUM_CELLS_PER_ROW - 1 && stringOutput[i] == "." && stringOutput[i + 1] == "0")
|| (i < NUM_CELLS_PER_ROW - 1 && stringOutput[i] == "=" && stringOutput[i + 1] == "0")
|| (i < NUM_CELLS_PER_ROW - 2 && stringOutput[i] == "=" && stringOutput[i + 1] == "-" && stringOutput[i + 2] == "0")
|| (i < NUM_CELLS_PER_ROW - 2 && stringOutput[i] == "≈" && stringOutput[i + 1] == "-" && stringOutput[i + 2] == "0")
|| (i < NUM_CELLS_PER_ROW - 1 && stringOutput[i] == "≈" && stringOutput[i + 1] == "0")
|| (i < NUM_CELLS_PER_ROW - 1 && stringOutput[i] == "-" && stringOutput[i + 1] == "0")
|| (i == NUM_CELLS_PER_ROW - 1 && stringOutput[i] == ".")
) ? CELL_GOOD_BACKGROUND_COLOR : CELL_CARD_BACKGROUND_COLOR
if (cellColor != CELL_GOOD_BACKGROUND_COLOR) {
won = false
}
setTimeout(() => {
cell.animate([
{transform: "scaleY(-1)", backgroundColor: CELL_HIDDEN_BACKGROUND_COLOR, color: CELL_HIDDEN_BACKGROUND_COLOR},
{transform: "scaleY(0)", backgroundColor: cellColor, color: CELL_FOREGROUND_COLOR},
{transform: "scaleY(1)", backgroundColor: cellColor, color: CELL_FOREGROUND_COLOR}
], {
duration: 500,
fill: "forwards",
easing: "ease-out"
})
}, NUM_CELLS_PER_ROW * 200 - i * 200)
}
row.appendChild(header)
row.appendChild(cells)
this.cellsContainer.appendChild(row)
return won
}
makeResultsString() {
const characterEmojiMap = {
"0": "0️⃣", "1": "1️⃣", "2": "2️⃣",
"3": "3️⃣", "4": "4️⃣", "5": "5️⃣",
"6": "6️⃣", "7": "7️⃣", "8": "8️⃣",
"9": "9️⃣", ".": "*️⃣", "-": "⛔"
}
let str = `Wurzle #${wurzleNumero} ${this.guesses.length}/${NUM_MAX_GUESSES}\n`
for (const guess of this.guesses) {
for (const char of guess.output) {
if (characterEmojiMap[char]) {
str += characterEmojiMap[char]
}
}
str += "\n"
}
str += `recmaths.ch/wurzle`
return str
}
endgame() {
fillDataElements("num-guesses", this.guesses.length)
wurzlePopupBackground.style.display = "block"
wurzleResultsPopup.style.display = "block"
wurzleInputContainer.style.display = "none"
wurzleShareContainer.style.display = "block"
this.resultString = this.makeResultsString()
}
win() {
this.endgame()
wurzleGoodResultsContainer.style.display = "block"
wurzleBadResultsContainer.style.display = "none"
}
lose() {
this.endgame()
wurzleGoodResultsContainer.style.display = "none"
wurzleBadResultsContainer.style.display = "block"
}
inputNumber(number) {
if (this.state !== WurzleGameState.Playing) {
return false
}
const stringInput = number.toString()
const stringOutput = this.wurzleFunction.computeStringResultAt(number)
this.guesses.push({input: stringInput, output: stringOutput})
const won = this.addHtmlRow(stringInput, stringOutput)
if (won) {
setTimeout(() => this.win(), 1700)
this.state = WurzleGameState.Results
} else if (this.guesses.length >= NUM_MAX_GUESSES) {
setTimeout(() => this.lose(), 1700)
this.state = WurzleGameState.Results
}
return won
}
}
const urlParams = new URLSearchParams(location.search)
let trainingModeActive = urlParams.has("training")
if (trainingModeActive) {
revealElements("trainingmode")
enableTrainingModeButton.style.display = "none"
secretFunctionString = functionGenerator.generate()
} else {
disableTrainingModeButton.style.display = "none"
}
const f = new WurzleFunction(secretFunctionString)
const wurzleGame = new WurzleGame(wurzleGridContainer, f)
fillDataElements("secret-function", "#".repeat(f.termString.length))
wurzleInput.addEventListener("input", () => {
if (wurzleInput.value.length > 18) {
wurzleInput.value = wurzleInput.value.slice(0, 18)
}
try {
if (wurzleInput.value.length > 0) {
evaluateNumberString(wurzleInput.value)
}
wurzleInput.style.color = "var(--input-color)"
} catch {
wurzleInput.style.color = "red"
}
})
wurzleSubmitButton.addEventListener("click", () => {
try {
const x = evaluateNumberString(wurzleInput.value)
wurzleGame.inputNumber(x)
wurzleInput.value = ""
} catch {}
})
wurzleInput.addEventListener("keydown", event => {
if (event.key == "Enter") {
wurzleSubmitButton.click()
}
})
for (const button of revealFunctionButtons) {
button.addEventListener("click", () => {
fillDataElements("secret-function", " " + f.termString)
for (const btn of revealFunctionButtons) {
btn.remove()
}
})
}
wurzleClosePopupButton.addEventListener("click", () => {
wurzlePopupBackground.style.display = "none"
wurzleResultsPopup.style.display = "none"
})
for (const button of shareResultsButtons) {
button.addEventListener("click", async () => {
const shareText = wurzleGame.resultString
const header = shareText.split("\n")[0]
if (navigator.share) {
navigator.share({
title: header,
text: shareText
})
} else {
await navigator.clipboard.writeText(shareText)
alert("Copied Text to Clipboard!")
}
})
if (trainingModeActive) {
button.disabled = true
}
}
enableTrainingModeButton.addEventListener("click", () => {
location.href += "?training"
})
disableTrainingModeButton.addEventListener("click", () => {
location.href = location.href.split("?")[0]
})
