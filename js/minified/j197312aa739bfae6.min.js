const secretFunctionString = "x^2-x-1"
const wurzleNumero = 1
const wurzleGameContainer = document.getElementById("wurzle-game-container")
const wurzleGridContainer = document.getElementById("wurzle-grid-container")
const wurzleGlobalContainer = document.getElementById("wurzle-global-container")
const wurzleInput = document.getElementById("wurzle-input")
const wurzleSubmitButton = document.getElementById("wurzle-submit-button")
const wurzleInputContainer = document.getElementById("wurzle-input-container")
const wurzleShareContainer = document.getElementById("wurzle-share-container")
const wurzleResultsPopup = document.getElementById("wurzle-results-popup")
const wurzleGoodResultsContainer = document.getElementById("wurzle-good-results-container")
const wurzleBadResultsContainer = document.getElementById("wurzle-bad-results-container")
const wurzlePopupBackground = document.getElementById("wurzle-popup-background")
const wurzleClosePopupButton = document.getElementById("close-popup-button")
const revealFunctionButtons = document.querySelectorAll(".function-reveal-button")
const shareResultsButtons = document.querySelectorAll(".share-results-button")
const NUM_CELLS_PER_ROW = 6
const NUM_MAX_GUESSES = 12
wurzleGameContainer.style.setProperty("--num-cells-per-row", NUM_CELLS_PER_ROW)
function updateCSSCellSize() {
const cell = wurzleGridContainer.querySelector(".wurzle-grid-cell")
if (cell) {
const cellSize = cell.clientWidth
wurzleGameContainer.style.setProperty("--cell-size-px", `${cellSize}px`)
}
}
function fillDataElements(key, value) {
for (const element of document.querySelectorAll(`[data-fill='${key}']`)) {
element.textContent = value
}
}
fillDataElements("max-num-guesses", NUM_MAX_GUESSES)
window.addEventListener("resize", updateCSSCellSize)
window.addEventListener("DOMContentLoaded", updateCSSCellSize)
const CELL_HIDDEN_BACKGROUND_COLOR = "var(--background)"
const CELL_CARD_BACKGROUND_COLOR = "grey"
const CELL_FOREGROUND_COLOR = "white"
const CELL_GOOD_BACKGROUND_COLOR = "#6aba65"
class NumberParserError extends Error {
constructor(message) {
super(message)
this.name = "NumberParserError"
}
}
function evaluateNumberString(numberString) { //argOption, error
const constants = {
"pi": Math.PI,
"π": Math.PI,
"tau": 2 * Math.PI,
"phi": (1 + Math.sqrt(5)) / 2,
"Φ": (1 + Math.sqrt(5)) / 2,
"goldenratio": (1 + Math.sqrt(5)) / 2,
"e": Math.E,
}
for (const [constant, value] of Object.entries(constants)) {
if (numberString == constant) {
return value
}
}
if (numberString == "inf") {
throw new NumberParserError(`Infinity is not a number`)
}
const decimalRegex = /^[0123456789]+\.[0123456789]+$/
const intRegex = /^[0123456789]+$/
const hexDecimalRegex = /^0x[0123456789abcdef]+\.[0123456789abcdef]+$/
const hexIntRegex = /^0x[0123456789abcdef]+$/
const binDecimalRegex = /^0b[01]+\.[01]+$/
const binIntRegex = /^0b[01]+$/
const scientificRegex = /^\-?[0123456789]+(\.[0123456789]+)?e-?[0123456789]+$/
if (numberString.startsWith("-")) {
return -evaluateNumberString(numberString.slice(1))
}
const allowedFunctions = {
"sqrt": {
compute: n => Math.sqrt(n),
constraints: [
{
if: n => (n < 0),
err: () => new NumberParserError(`sqrt is only defined on [0, inf)`)
}
]
},
"abs":     {compute: n => Math.abs(n)},
"sin":     {compute: n => Math.sin(n)},
"cos":     {compute: n => Math.cos(n)},
"tan":     {compute: n => Math.tan(n)},
"arcsin":  {
compute: n => Math.asin(n),
constraints: [
{
if: n => (n < -1) || (n > 1),
err: () => new NumberParserError(`arcsin is only defined on [-1, 1]`)
}
]
},
"arccos":  {
compute: n => Math.acos(n),
constraints: [
{
if: n => (n < -1) || (n > 1),
err: () => new NumberParserError(`arccos is only defined on [-1, 1]`)
}
]
},
"arctan":  {compute: n => Math.atan(n)},
"sinh":    {compute: n => Math.sinh(n)},
"cosh":    {compute: n => Math.cosh(n)},
"tanh":    {compute: n => Math.tanh(n)},
"arcsinh": {compute: n => Math.asinh(n)},
"arccosh": {
compute: n => Math.acosh(n),
constraints: [
{
if: n => (n < 1),
err: () => new NumberParserError(`arccosh is only defined on [1, inf)`)
}
]
},
"arctanh": {
compute: n => Math.atanh(n),
constraints: [
{
if: n => (n <= -1) || (n >= 1),
err: () => new NumberParserError(`arctanh is only defined on (-1, 1)`)
}
]
},
"": {compute: n => n}
}
for (const [functionStr, func] of Object.entries(allowedFunctions)) {
if (numberString.startsWith(`${functionStr}(`)) {
const numberPart = numberString.slice(functionStr.length + 1, -1)
let openCount = 0
let abortThisExecution = false
for (const char of numberPart) {
if (char == "(") {
openCount++
} else if (char == ")") {
openCount--
}
if (openCount < 0) {
abortThisExecution = true
break
}
}
if (abortThisExecution) {
continue
}
const value = evaluateNumberString(numberPart)
for (const constraint of (func.constraints ?? [])) {
if (constraint.if(value)) {
throw constraint.err()
}
}
return func.compute(value)
}
}
if (intRegex.test(numberString)) {
return parseInt(numberString)
} else if (hexIntRegex.test(numberString)) {
return parseInt(numberString.slice(2), 16)
} else if (binIntRegex.test(numberString)) {
return parseInt(numberString.slice(2), 2)
}
if (decimalRegex.test(numberString)) {
return parseFloat(numberString)
} else if (binDecimalRegex.test(numberString)) {
const [before, after] = numberString.split(".")
const beforeVal = parseInt(before.slice(2), 2)
const afterVal = parseInt(after, 2)
return beforeVal + afterVal / (2 ** after.length)
} else if (hexDecimalRegex.test(numberString)) {
const [before, after] = numberString.split(".")
const beforeVal = parseInt(before.slice(2), 16)
const afterVal = parseInt(after, 16)
return beforeVal + afterVal / (16 ** after.length)
}
if (scientificRegex.test(numberString)) {
let [decimal, exponent] = numberString.split("e")
decimal = parseFloat(decimal)
exponent = parseInt(exponent)
return decimal * (10 ** exponent)
}
const operators = [
["+", (a, b) => a + b],
["-", (a, b) => a - b],
["*", (a, b) => a * b],
["/", (a, b) => a / b],
["^", (a, b) => a ** b],
]
for (const [operatorName, operatorFunc] of operators) {
let currLevel = 0
let foundSplitIndex = null
for (let i = 0; i < numberString.length; i++) {
const char = numberString[i]
if (char == "(") currLevel++
if (char == ")") currLevel--
if (currLevel < 0) {
throw new NumberParserError(`Unbalanced parentheses`)
}
if (char == operatorName && currLevel == 0) {
foundSplitIndex = i
}
}
if (currLevel != 0) {
throw new NumberParserError(`Unbalanced parentheses`)
}
if (foundSplitIndex === null) {
continue
}
const parts = [
numberString.slice(0, foundSplitIndex),
numberString.slice(foundSplitIndex + 1)
]
for (let i = 0; i < 2; i++) {
parts[i] = evaluateNumberString(parts[i])
}
if (parts[1] == 0 && operatorName == "/") {
throw new NumberParserError(`Can't divide by zero`)
}
return operatorFunc(parts[0], parts[1])
}
throw new NumberParserError(`Invalid number`)
}
class WurzleFunction {
constructor(termString) {
this.termString = termString
}
computeAt(x) {
return evaluateNumberString(this.termString.replaceAll("x", `(${x})`))
}
numericToStringResult(y) {
const maxPositiveNumber = 10 ** (NUM_CELLS_PER_ROW - 1) - 1
const maxNegativeNumber = -(10 ** (NUM_CELLS_PER_ROW - 2) - 1)
if (y > maxPositiveNumber) {
return ">" + maxPositiveNumber
} else if (y < maxNegativeNumber) {
return "<" + maxNegativeNumber
} else {
let yString = y.toFixed(NUM_CELLS_PER_ROW)
if (yString.startsWith("-")) {
const lengthBeforePoint = yString.length - NUM_CELLS_PER_ROW - 2
const availableDigits = Math.max(NUM_CELLS_PER_ROW - lengthBeforePoint - 3, 0)
yString = y.toFixed(availableDigits)
} else {
const lengthBeforePoint = yString.length - NUM_CELLS_PER_ROW - 1
const availableDigits = Math.max(NUM_CELLS_PER_ROW - lengthBeforePoint - 2, 0)
yString = y.toFixed(availableDigits)
}
if (yString.length < NUM_CELLS_PER_ROW - 1) {
yString = yString + "."
}
console.assert(yString.length == NUM_CELLS_PER_ROW - 1)
if (parseFloat(yString) == y) {
return `=${yString}`
} else {
return `≈${yString}`
}
}
}
computeStringResultAt(x) {
let y = null
try {
y = this.computeAt(x)
} catch (e) {
if (e instanceof NumberParserError) {
return "undefined".slice(0, NUM_CELLS_PER_ROW).padStart(NUM_CELLS_PER_ROW, " ")
} else {
throw e
}
}
return this.numericToStringResult(y)
}
}
const WurzleGameState = {
Playing: "playing",
Results: "results"
}
class WurzleGame {
constructor(cellsContainer, wurzleFunction) {
this.cellsContainer = cellsContainer
this.wurzleFunction = wurzleFunction
this.guesses = []
this.state = WurzleGameState.Playing
}
addHtmlRow(stringInput, stringOutput) {
/*
<div class="wurzle-grid-row">
<div class="wurzle-grid-row-header">
f(0.123)
</div>
<div class="wurzle-grid-row-cells">
<div class="wurzle-grid-cell">&lt;</div>
<div class="wurzle-grid-cell">-</div>
<div class="wurzle-grid-cell">9</div>
<div class="wurzle-grid-cell">9</div>
<div class="wurzle-grid-cell">9</div>
</div>
</div>
*/
const row = document.createElement("div")
row.classList.add("wurzle-grid-row")
const header = document.createElement("div")
header.classList.add("wurzle-grid-row-header")
header.textContent = `f(${stringInput})`
const cells = document.createElement("div")
cells.classList.add("wurzle-grid-row-cells")
let won = true
for (let i = 0; i < NUM_CELLS_PER_ROW; i++) {
const cell = document.createElement("div")
cell.classList.add("wurzle-grid-cell")
if (i < stringOutput.length) {
cell.textContent = stringOutput[i]
} else {
cell.textContent = "_"
}
cells.appendChild(cell)
cell.style.transform = "scaleY(-1)"
cell.style.color = CELL_HIDDEN_BACKGROUND_COLOR
cell.style.backgroundColor = CELL_HIDDEN_BACKGROUND_COLOR
let cellColor = (
stringOutput[i] == "0"
|| (i < NUM_CELLS_PER_ROW - 1 && stringOutput[i] == "." && stringOutput[i + 1] == "0")
|| (i < NUM_CELLS_PER_ROW - 1 && stringOutput[i] == "=" && stringOutput[i + 1] == "0")
|| (i < NUM_CELLS_PER_ROW - 2 && stringOutput[i] == "=" && stringOutput[i + 1] == "-" && stringOutput[i + 2] == "0")
|| (i < NUM_CELLS_PER_ROW - 2 && stringOutput[i] == "≈" && stringOutput[i + 1] == "-" && stringOutput[i + 2] == "0")
|| (i < NUM_CELLS_PER_ROW - 1 && stringOutput[i] == "≈" && stringOutput[i + 1] == "0")
|| (i < NUM_CELLS_PER_ROW - 1 && stringOutput[i] == "-" && stringOutput[i + 1] == "0")
|| (i == NUM_CELLS_PER_ROW - 1 && stringOutput[i] == ".")
) ? CELL_GOOD_BACKGROUND_COLOR : CELL_CARD_BACKGROUND_COLOR
if (cellColor != CELL_GOOD_BACKGROUND_COLOR) {
won = false
}
setTimeout(() => {
cell.animate([
{transform: "scaleY(-1)", backgroundColor: CELL_HIDDEN_BACKGROUND_COLOR, color: CELL_HIDDEN_BACKGROUND_COLOR},
{transform: "scaleY(0)", backgroundColor: cellColor, color: CELL_FOREGROUND_COLOR},
{transform: "scaleY(1)", backgroundColor: cellColor, color: CELL_FOREGROUND_COLOR}
], {
duration: 500,
fill: "forwards",
easing: "ease-out"
})
}, NUM_CELLS_PER_ROW * 200 - i * 200)
}
row.appendChild(header)
row.appendChild(cells)
this.cellsContainer.appendChild(row)
return won
}
makeResultsString() {
const characterEmojiMap = {
"0": "0️⃣", "1": "1️⃣", "2": "2️⃣",
"3": "3️⃣", "4": "4️⃣", "5": "5️⃣",
"6": "6️⃣", "7": "7️⃣", "8": "8️⃣",
"9": "9️⃣", ".": "*️⃣", "-": "⛔"
}
let str = `Wurzle #${wurzleNumero} ${this.guesses.length}/${NUM_MAX_GUESSES}\n`
for (const guess of this.guesses) {
for (const char of guess.output) {
if (characterEmojiMap[char]) {
str += characterEmojiMap[char]
}
}
str += "\n"
}
str += `recmaths.ch/wurzle`
return str
}
endgame() {
fillDataElements("num-guesses", this.guesses.length)
wurzlePopupBackground.style.display = "block"
wurzleResultsPopup.style.display = "block"
wurzleInputContainer.style.display = "none"
wurzleShareContainer.style.display = "block"
this.resultString = this.makeResultsString()
}
win() {
this.endgame()
wurzleGoodResultsContainer.style.display = "block"
wurzleBadResultsContainer.style.display = "none"
}
lose() {
this.endgame()
wurzleGoodResultsContainer.style.display = "none"
wurzleBadResultsContainer.style.display = "block"
}
inputNumber(number) {
if (this.state !== WurzleGameState.Playing) {
return false
}
const stringInput = number.toString()
const stringOutput = this.wurzleFunction.computeStringResultAt(number)
this.guesses.push({input: stringInput, output: stringOutput})
const won = this.addHtmlRow(stringInput, stringOutput)
if (won) {
setTimeout(() => this.win(), 1700)
this.state = WurzleGameState.Results
} else if (this.guesses.length >= NUM_MAX_GUESSES) {
setTimeout(() => this.lose(), 1700)
this.state = WurzleGameState.Results
}
return won
}
}
const f = new WurzleFunction(secretFunctionString)
const wurzleGame = new WurzleGame(wurzleGridContainer, f)
fillDataElements("secret-function", "#".repeat(f.termString.length))
wurzleInput.addEventListener("input", () => {
if (wurzleInput.value.length > 18) {
wurzleInput.value = wurzleInput.value.slice(0, 18)
}
try {
if (wurzleInput.value.length > 0) {
evaluateNumberString(wurzleInput.value)
}
wurzleInput.style.color = "var(--input-color)"
} catch {
wurzleInput.style.color = "red"
}
})
wurzleSubmitButton.addEventListener("click", () => {
try {
const x = evaluateNumberString(wurzleInput.value)
wurzleGame.inputNumber(x)
wurzleInput.value = ""
} catch {}
})
wurzleInput.addEventListener("keydown", event => {
if (event.key == "Enter") {
wurzleSubmitButton.click()
}
})
for (const button of revealFunctionButtons) {
button.addEventListener("click", () => {
fillDataElements("secret-function", " " + f.termString)
for (const btn of revealFunctionButtons) {
btn.remove()
}
})
}
wurzleClosePopupButton.addEventListener("click", () => {
wurzlePopupBackground.style.display = "none"
wurzleResultsPopup.style.display = "none"
})
for (const button of shareResultsButtons) {
button.addEventListener("click", async () => {
const shareText = wurzleGame.resultString
const header = shareText.split("\n")[0]
if (navigator.share) {
navigator.share({
title: header,
text: shareText
})
} else {
await navigator.clipboard.writeText(`${header}\n\n${shareText}`)
alert("Copied Text to Clipboard!")
}
})
}
