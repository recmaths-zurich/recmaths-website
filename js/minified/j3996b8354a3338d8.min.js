const questionsContainer = document.getElementById("questions-container")
const resultsContainer = document.getElementById("results-container")
const finishQuestionsButton = document.getElementById("finish-questions-button")
const resultFunction = document.getElementById("result-function")
const resultDescription = document.getElementById("result-description")
const resultFunctionCanvas = document.getElementById("result-function-canvas")
const resultFunctionContext = resultFunctionCanvas.getContext("2d")
const resultsTableBody = document.getElementById("results-table-body")
const shareResultsButton = document.getElementById("share-results-button")
const NUM_BUTTONS_PER_QUESTION = 7
function shuffle(array) {
let m = array.length, t, i
while (m) {
i = Math.floor(Math.random() * m--)
t = array[m]
array[m] = array[i]
array[i] = t
}
return array
}
const TestResultCategories = {
Oscillation: 1,
Growth: 2,
Chaotic: 3,
Logical: 4
}
const TestResultCategoryNames = {
Chaotic: {
en: "Chaotic",
de: "Chaotisch"
},
Logical: {
en: "Logical",
de: "Logisch"
},
Oscillation: {
en: "Oscillation",
de: "Schwingung"
},
Growth: {
en: "Growth",
de: "Wachstum"
}
}
const TestQuestions = [
{
statement: {
en: "You enjoy taking risks.",
de: "Du genießt es, Risiken einzugehen."
},
effect: {
agree: { Growth: 0.7, Oscillation: -1.2 },
disagree: { Growth: -0.6, Oscillation: 1.03 }
}
},
{
statement: {
en: "You know your limits and don't push them.",
de: "Du kennst deine Grenzen und überschreitest sie nicht."
},
effect: {
agree: { Growth: -1.2 },
disagree: { Growth: 0.82 }
}
},
{
statement: {
en: "You are very organized and like to plan ahead.",
de: "Du bist sehr organisiert und planst gerne im Voraus."
},
effect: {
agree: { Chaotic: -1.3 },
disagree: { Chaotic: 1.1 }
}
},
{
statement: {
en: "When your heart disagrees with your mind, you follow your heart.",
de: "Wenn dein Herz nicht mit deinem Verstand übereinstimmt, folgst du deinem Herzen."
},
effect: {
agree: { Logical: -0.9 },
disagree: { Logical: 1.2 }
}
},
{
statement: {
en: "You are always on the move and can't sit still.",
de: "Du bist immer in Bewegung und kannst nicht stillsitzen."
},
effect: {
agree: { Oscillation: 1.4 },
disagree: { Oscillation: -1.1 }
}
},
{
statement: {
en: "You like to be the center of attention.",
de: "Du magst es, im Mittelpunkt zu stehen."
},
effect: {
agree: { Growth: 1.1 },
disagree: { Growth: -1.2 }
}
},
{
statement: {
en: "You are very emotional and always follow your feelings.",
de: "Du bist sehr emotional und folgst immer deinen Gefühlen."
},
effect: {
agree: { Logical: -1.8 },
disagree: { Logical: 1.6 }
}
},
{
statement: {
en: "You like to take things slow and steady.",
de: "Du magst es, die Dinge langsam und stetig anzugehen."
},
effect: {
agree: { Oscillation: -1, Chaotic: 0.5, Growth: -0.5 },
disagree: { Oscillation: 1, Chaotic: -0.5, Growth: 0.5 }
}
},
{
statement: {
en: "You don't like to try new things and experiment.",
de: "Du magst es nicht, neue Dinge auszuprobieren und zu experimentieren."
},
effect: {
agree: { Chaotic: -1.2, Growth: -0.59 },
disagree: { Chaotic: 1.1, Growth: 0.52 }
}
},
{
statement: {
en: "You love prime numbers.",
de: "Du liebst Primzahlen."
},
effect: {
agree: { Chaotic: 0.6, Oscillation: -0.6, Logical: 0.7 },
disagree: { Chaotic: -0.8, Oscillation: 0.45, Logical: -0.6 }
}
},
{
statement: {
en: "You love calculating derivatives.",
de: "Du liebst es, Ableitungen zu berechnen."
},
effect: {
agree: { Chaotic: -0.5, Logical: 1.2 },
disagree: { Chaotic: 0.7, Logical: -1 }
}
},
{
statement: {
en: "You have a favorite mathematical constant.",
de: "Du hast eine Lieblings mathematische Konstante."
},
effect: {
agree: { Chaotic: -0.3, Oscillation: 0.5, Logical: 1.1 },
disagree: { Chaotic: 0.6, Oscillation: -0.4, Logical: -1 }
}
},
{
statement: {
en: "Sometimes you feel like you are on a rollercoaster.",
de: "Manchmal fühlt es sich an, als wärst du auf einer Achterbahn."
},
effect: {
agree: { Oscillation: 1.2, Chaotic: -0.8 },
disagree: { Oscillation: -1.1, Chaotic: 0.7 }
}
},
{
statement: {
en: "You often find yourself asking mathematical questions in everyday life.",
de: "Du stellst dir oft mathematische Fragen im Alltag."
},
effect: {
agree: { Logical: 1.3, Chaotic: 0.51 },
disagree: { Logical: -1.2, Chaotic: -0.52 }
}
},
{
statement: {
en: "You can't prove the irrationality of sqrt(2) without asking ChatGPT.",
de: "Du kannst die Irrationalität von sqrt(2) nicht beweisen, ohne ChatGPT zu fragen."
},
effect: {
agree: { Logical: -1.4, Chaotic: 0.7 },
disagree: { Logical: 1.5, Chaotic: -0.6 }
}
},
{
statement: {
en: "Small numbers are more interesting than large numbers.",
de: "Kleine Zahlen sind interessanter als große Zahlen."
},
effect: {
agree: { Growth: -2 },
disagree: { Growth: 2.5 }
}
},
{
statement: {
en: "You have been to a recreational Maths meetup.",
de: "Du warst schon mal bei einem Recreational Maths Meetup."
},
effect: {
agree: { Chaotic: 0.8, Growth: 0.6 },
disagree: { Chaotic: -0.7, Growth: -0.5 }
}
},
{
statement: {
en: "When playing games, you never think about the optimal strategy.",
de: "Beim Spielen denkst du nie über die optimale Strategie nach."
},
effect: {
agree: { Logical: -1.3, Chaotic: 0.6 },
disagree: { Logical: 1.4, Chaotic: -0.5 }
}
},
{
statement: {
en: "You enjoy teaching abstract concepts to others.",
de: "Du erklärst anderen gerne abstrakte Konzepte."
},
effect: {
agree: { Growth: 0.9, Chaotic: 0.2 },
disagree: { Growth: -1.2, Chaotic: -0.1 }
}
},
{
statement: {
en: "You prefer working alone rather than in a group.",
de: "Du arbeitest lieber alleine als im Team."
},
effect: {
agree: { Chaotic: -0.7, Growth: 0.5, Logical: 0.6, Oscillation: -0.4 },
disagree: { Chaotic: 0.8, Growth: -0.6, Logical: -0.7, Oscillation: 0.5 }
}
}
]
const TestResults = [
{
termString: "x",
location: {
Growth: 0,
Chaotic: 0,
Logical: 0,
Oscillation: 0
},
description: {
en: 'You are steady, reliable and perfectly balanced, treating everyone equally and having a strong sense of justice. You are the “what you see is what you get” type of person, which can make you bit predictable, but sometimes is exactly what you need in a world full of complications: someone who keeps things perfectly in line.',
de: 'Du bist stabil, zuverlässig und perfekt ausgewogen, behandelst jeden gleich und hast ein starkes Gerechtigkeitsempfinden. Du bist der Typ „was du siehst, ist was du bekommst“, was dich etwas vorhersehbar machen kann, aber manchmal ist genau das was du in einer Welt voller Komplikationen brauchst: jemanden, der die Dinge perfekt in Ordnung hält.'
},
},
{
termString: "sin(x)",
location: {
Growth: 0,
Chaotic: 0,
Logical: 0,
Oscillation: 1
},
description: {
en: "You are smooth, rhythmic, and perfectly in tune with life’s ups and downs. Your friends appreciate your reliability and impeccable sense of timing – they can always count on your periodic check-ins, and you bring waves of harmony wherever you go. Yet you rarely step outside your comfort zone and sometimes feel unsatisfied, as if life is always repeating the same cycles — but at least you never get led off on pointless tangents.",
de: "Du bist sanft, rhythmisch und perfekt im Einklang mit den Höhen und Tiefen des Lebens. Deine Freunde schätzen deine Zuverlässigkeit und dein makelloses Timing – sie können sich immer auf deine regelmäßigen Besuche verlassen, und du bringst Wellen der Harmonie, wohin du auch gehst. Dennoch verlässt du selten deine Komfortzone und fühlst dich manchmal unzufrieden, als ob das Leben immer die gleichen Zyklen wiederholt – aber zumindest wirst du nie auf sinnlose Tangenten geführt."
}
},
{
termString: "factorial(x)",
location: {
Growth: 1,
Chaotic: 0,
Logical: 0,
Oscillation: 0
},
description: {
en: "You light up in a crowd, and your social circle multiplies fast: each new connection bigger than the one before. You’re lively yet methodical, always building on what’s come before. You only move in the positive direction, which keeps you upbeat, but sometimes you pile on so much that even you wonder how you’ll handle it all.",
de: "Du leuchtest in einer Menschenmenge auf, und dein Freundeskreis vergrößert sich schnell: jede neue Verbindung ist größer als die vorherige. Du bist lebhaft und doch methodisch, baust immer auf dem auf, was zuvor kam. Du bewegst dich nur in positiver Richtung, was dich optimistisch hält, aber manchmal häufst du so viel an, dass du dich fragst, wie du das alles bewältigen wirst."
}
},
{
termString: "tan(x)",
location: {
Growth: 0,
Chaotic: 1,
Logical: 0,
Oscillation: 0
},
description: {
en: "Your life is full of excitement: there’s always something happening, and you try to take part in it all. Friends know you as the life of the party, moving effortlessly from one moment to the next. But with so much going on, it’s easy to lose track; you might skip an obligation now and then or vanish for a while before reappearing right on cue, bringing a spark people can always count on.",
de: "Dein Leben ist voller Aufregung: Es passiert immer etwas, und du versuchst, an allem teilzunehmen. Freunde kennen dich als das Leben der Party, das mühelos von einem Moment zum nächsten wechselt. Aber bei so viel los ist es leicht, den Überblick zu verlieren; du könntest jetzt und dann eine Verpflichtung auslassen oder eine Weile verschwinden, bevor du genau im richtigen Moment wieder auftauchst und einen Funken bringst, auf den die Leute sich immer verlassen können."
}
},
{
termString: "e^x",
location: {
Growth: 1,
Chaotic: 0,
Logical: 1,
Oscillation: 0
},
description: {
en: "You grow at full speed, powered by a drive that comes entirely from within: you’re your own source of momentum. Bold and logical, you approach challenges with precision, planning each move to keep your exponential rise on track. But your focus on constant growth can make you sometimes seem cold and impatient with slower paces, and that’s when the logarithm helps bring you back down to earth.",
de: "Du wächst mit voller Geschwindigkeit, angetrieben von einem Antrieb, der ganz aus dir selbst kommt: du bist deine eigene Quelle der Dynamik. Kühn und logisch gehst du Herausforderungen mit Präzision an und planst jeden Schritt, um dein exponentielles Wachstum auf Kurs zu halten. Aber dein Fokus auf ständiges Wachstum kann dich manchmal kalt und ungeduldig gegenüber langsameren Tempi erscheinen lassen, und dann hilft dir der Logarithmus, wieder auf den Boden der Tatsachen zurückzukommen."
}
},
{
termString: "pi",
location: {
Growth: 0,
Chaotic: 0,
Logical: 0,
Oscillation: -1
},
description: {
en: "You are content with the way things are and so stable that you might seem plain at first glance, but once people discover your interesting features, they can’t help but appreciate you more. You act irrationally and follow your emotions more than most, but that‘s exactly what makes you a great companion: always there to help and making sure everything‘s coming full circle.",
de: "Du bist zufrieden mit dem, wie die Dinge sind und so stabil, dass du auf den ersten Blick vielleicht einfach erscheinst, aber sobald die Leute deine interessanten Eigenschaften entdecken, können sie nicht anders, als dich mehr zu schätzen. Du handelst irrational und folgst deinen Emotionen mehr als die meisten, aber genau das macht dich zu einem großartigen Begleiter: immer da, um zu helfen und sicherzustellen, dass alles wieder in Einklang kommt."
}
},
{
termString: "log(x)",
location: {
Growth: -1,
Chaotic: -1,
Logical: 0,
Oscillation: 0
},
description: {
en: "You prefer a quiet, measured pace: quick to respond at first, then settling into a slow, deliberate flow. Structure is your comfort zone, and you like keeping things orderly and proportional. As the inverse of the exponential, you’re the one who brings their boundless energy back into balance. Some may see your reserved nature as a lack of drive, but you simply know the value of setting limits and keeping life within bounds.",
de: "Du bevorzugst ein ruhiges, gemessenes Tempo: Zunächst schnell in der Reaktion, dann in einen langsamen, bedachten Fluss übergehend. Struktur ist deine Komfortzone, und du magst es, die Dinge ordentlich und proportional zu halten. Als Inverses des Exponentialen bist du derjenige, der ihre grenzenlose Energie wieder ins Gleichgewicht bringt. Einige sehen deine zurückhaltende Natur vielleicht als Mangel an Antrieb, aber du kennst einfach den Wert von Grenzen und hältst das Leben im Rahmen."
}
},
{
termString: "abs(x-1)+abs(x+1)",
location: {
Growth: 0,
Chaotic: 0,
Logical: -1,
Oscillation: 0
},
description: {
en: "You make zero sense. You are the absolute value function, but you are always at least 2 units away from zero. You're really the most illogical function here, but that makes you fun and nice.",
de: "Du machst keinen Sinn. Du bist die Absolutwertfunktion, aber du bist immer mindestens 2 Einheiten von Null entfernt. Du bist wirklich die unlogischste Funktion hier, aber das macht dich spaßig und nett."
}
},
{
termString: "sqrt(x)+sin(x)",
location: {
Growth: 0.3,
Chaotic: -0.5,
Logical: 0.5,
Oscillation: 0.7
},
description: {
en: "You are the square root function plus sine. You are very balanced and have a good mix of growth, chaos, logic, and oscillation. You are a very well-rounded person and can adapt to any situation.",
de: "Du bist die Quadratwurzelfunktion plus Sinus. Du bist sehr ausgewogen und hast eine gute Mischung aus Wachstum, Chaos, Logik und Schwingung. Du bist eine sehr vielseitige Person und kannst dich jeder Situation anpassen."
}
},
{
termString: "x^2",
location: {
Growth: 0.5,
Chaotic: 0,
Logical: 1,
Oscillation: -0.5
},
description: {
en: "You are the quadratic function. You are very bold and always take risks. You grow rapidly and don't fear to expand your horizons. You are very reliable and always keep your promises.",
de: "Du bist die quadratische Funktion. Du bist sehr mutig und gehst immer Risiken ein. Du wächst schnell und scheust dich nicht, deine Horizonte zu erweitern. Du bist sehr zuverlässig und hältst immer deine Versprechen."
}
},
{
termString: "cos(x)",
location: {
Growth: 0,
Chaotic: 0,
Logical: -1,
Oscillation: 1
},
description: {
en: 'You share the same steady rhythm as your friend sin(x), but navigate life mostly by intuition rather than calculation. You start at the peak and then just go with the flow, following the sines, which can sometimes leave you feeling overly dependent on others and a bit out of sync with the world. Still, that unique phase is what makes you who you are, adding just the right shift to keep things interesting.',
de: 'Du teilst den gleichen stetigen Rhythmus wie dein Freund sin(x), navigierst aber das Leben hauptsächlich nach Intuition und nicht nach Berechnung. Du startest am Gipfel und gehst dann einfach mit dem Fluss, folgst den Sinuskurven, was dich manchmal etwas zu abhängig von anderen und ein wenig aus dem Takt mit der Welt fühlen lässt. Dennoch ist diese einzigartige Phase das, was dich ausmacht und genau die richtige Verschiebung hinzufügt, um die Dinge interessant zu halten.'
}
},
{
termString: "x^3",
location: {
Growth: -0.5,
Chaotic: -0.3,
Logical: 0.7,
Oscillation: 0
},
description: {
en: "You are the cubic function. You've been through a lot, but you always come out stronger. You are very logical and always follow a clear path. You are very reliable and always keep your promises.",
de: "Du bist die kubische Funktion. Du hast viel durchgemacht, aber du kommst immer stärker heraus. Du bist sehr logisch und folgst immer einem klaren Weg. Du bist sehr zuverlässig und hältst immer deine Versprechen."
}
},
{
termString: "-x",
location: {
Growth: -1,
Chaotic: -1,
Logical: 1,
Oscillation: 0
},
description: {
en: "You move through life with quiet precision, logical to the core and never straying from your straight path. You value clear rules and the elegance of simple solutions, taking satisfaction in keeping things perfectly balanced. Your tendency to flip situations around can make you seem overly negative at times, but in truth you’re simply showing the other side, a perspective that keeps everything in check.",
de: "Du bewegst dich mit ruhiger Präzision durch das Leben, logisch bis ins Mark und weicht nie von deinem geraden Weg ab. Du schätzt klare Regeln und die Eleganz einfacher Lösungen und findest Zufriedenheit darin, die Dinge perfekt im Gleichgewicht zu halten. Deine Neigung, Situationen umzudrehen, kann dich manchmal zu negativ erscheinen lassen, aber in Wahrheit zeigst du einfach die andere Seite, eine Perspektive, die alles im Gleichgewicht hält."
}
},
{
termString: "abs(x)",
location: { Growth: 0.3, Chaotic: -0.6, Logical: 0.8, Oscillation: -0.2 },
description: {
en: "You are the absolute value. No matter how life dips, you bounce back non-negative. Steady, resilient, and sensibly practical.",
de: "Du bist der Betrag. Egal, wie das Leben abfällt - du prallst nichtnegativ zurück. Beständig, widerstandsfähig und pragmatisch."
}
},
{
termString: "1/x",
location: { Growth: 0.0, Chaotic: 0.7, Logical: 0.2, Oscillation: 0.1 },
description: {
en: "You're the reciprocal. Most days are smooth, but you have dramatic asymptotes. People learn to respect your boundaries.",
de: "Du bist der Kehrwert. Meistens läuft es glatt, doch du hast dramatische Asymptoten. Man lernt, deine Grenzen zu respektieren."
}
},
{
termString: "sin(x)/x",
location: { Growth: 0.1, Chaotic: -0.2, Logical: 0.4, Oscillation: 0.8 },
description: {
en: "You're sinc. You oscillate, but your waves settle. Big energy, then measured ripples—refined enthusiasm. Engineers love you.",
de: "Du bist sinc. Du schwingst, aber die Wellen beruhigen sich. Erst viel Energie, dann maßvolle Wellen - verfeinerte Begeisterung. Ingenieure lieben dich."
}
},
{
termString: "e^(-x^2)",
location: { Growth: -0.2, Chaotic: -0.6, Logical: 0.5, Oscillation: 0 },
description: {
en: "You're the Gaussian. Centered, focused, and soothing. People come to you when they need calm clarity.",
de: "Du bist die Gauß-Funktion. Zentriert, fokussiert und beruhigend. Man kommt zu dir, wenn Ruhe und Klarheit gefragt sind."
}
},
{
termString: "cosh(x)",
location: { Growth: 0.8, Chaotic: 0.0, Logical: 0.7, Oscillation: -0.3 },
description: {
en: "You're hyperbolic cosine. Quietly dramatic—no waves, just majestic rise. Ambitious with serene poise. You won't keep anyone hanging, because you're literally the formula of a chain hanging.",
de: "Du bist der hyperbolische Kosinus. Leise dramatisch – keine Wellen, nur majestätischer Anstieg. Ehrgeizig mit gelassener Haltung. Du lässt niemanden hängen, denn du bist buchstäblich die Formel einer hängenden Kette."
}
},
{
termString: "arctan(x)",
location: { Growth: -0.2, Chaotic: 0.5, Logical: -0.9, Oscillation: -0.5 },
description: {
en: "You're arctangent. You don't get carried away—everything saturates. Wise, bounded, and great at perspective.",
de: "Du bist der Arkustangens. Du lässt dich nicht mitreißen - alles sättigt sich. Weise, begrenzt und stark in der Perspektive."
}
},
]
class Vector2d {
constructor(x, y) {
this.x = x
this.y = y
}
static get zero() {
return new Vector2d(0, 0)
}
static fromFunc(f) {
return new Vector2d(f(0), f(1))
}
copy() {
return new Vector2d(this.x, this.y)
}
add(v) {
return new Vector2d(this.x + v.x, this.y + v.y)
}
iadd(v) {
this.x += v.x
this.y += v.y
}
sub(v) {
return new Vector2d(this.x - v.x, this.y - v.y)
}
isub(v) {
this.x -= v.x
this.y -= v.y
}
mul(v) {
return new Vector2d(this.x * v.x, this.y * v.y)
}
imul(v) {
this.x *= v.x
this.y *= v.y
}
div(v) {
return new Vector2d(this.x / v.x, this.y / v.y)
}
idiv(v) {
this.x /= v.x
this.y /= v.y
}
get length() {
return Math.sqrt(this.x * this.x + this.y * this.y)
}
get normalized() {
let m = this.length
return new Vector2d(this.x / m, this.y / m)
}
scale(x) {
return new Vector2d(this.x * x, this.y * x)
}
lerp(v, t) {
let delta = v.sub(this)
return this.add(delta.scale(t))
}
dot(v) {
return this.x * v.x + this.y * v.y
}
iscale(x) {
this.x *= x
this.y *= x
}
distance(v) {
return this.sub(v).length
}
cross(v) {
return this.x * v.y - this.y * v.x
}
round() {
return new Vector2d(Math.round(this.x), Math.round(this.y))
}
static fromAngle(angle) {
return new Vector2d(Math.cos(angle), Math.sin(angle))
}
static fromPolar(mag, angle) {
return new Vector2d(mag * Math.cos(angle), mag * Math.sin(angle))
}
static fromArray(arr) {
return new Vector2d(arr[0], arr[1])
}
set(x, y) {
if (x instanceof Vector2d && y == undefined) {
this.x = x.x
this.y = x.y
} else {
this.x = x
this.y = y
}
}
addX(x) {
return new Vector2d(this.x + x, this.y)
}
addY(y) {
return new Vector2d(this.x, this.y + y)
}
rotate(angle) {
let x = this.x * Math.cos(angle) - this.y * Math.sin(angle)
let y = this.x * Math.sin(angle) + this.y * Math.cos(angle)
return new Vector2d(x, y)
}
irotate(angle) {
let x = this.x * Math.cos(angle) - this.y * Math.sin(angle)
let y = this.x * Math.sin(angle) + this.y * Math.cos(angle)
this.x = x
this.y = y
}
static random() {
let direction = Math.random() * Math.PI * 2
return Vector2d.fromAngle(direction)
}
get angle() {
return Math.atan2(this.y, this.x)
}
angleDifference(v) {
return angleDifference(this.angle, v.angle)
}
angleTo(v) {
return Math.atan2(v.y - this.y, v.x - this.x)
}
equals(v) {
return this.x == v.x && this.y == v.y
}
map(f) {
return new Vector2d(f(this.x), f(this.y))
}
product() {
return this.x * this.y
}
get array() {
return [this.x, this.y]
}
get min() {
return Math.min(...this.array)
}
get max() {
return Math.max(...this.array)
}
abs() {
return new Vector2d(Math.abs(this.x), Math.abs(this.y))
}
toArray() {
return [this.x, this.y]
}
static fromEvent(event, element) {
let x = 0, y = 0
if (event.touches && event.touches[0]) {
x = event.touches[0].clientX
y = event.touches[0].clientY
} else if (event.originalEvent && event.originalEvent.changedTouches[0]) {
x = event.originalEvent.changedTouches[0].clientX
y = event.originalEvent.changedTouches[0].clientY
} else if (event.clientX !== undefined && event.clientY !== undefined) {
x = event.clientX
y = event.clientY
} else if (event.changedTouches && event.changedTouches.length > 0) {
x = event.changedTouches[0].clientX
y = event.changedTouches[0].clientY
}
const rect = element.getBoundingClientRect()
return new Vector2d(x - rect.left, y - rect.top)
}
}
class NumberParserError extends Error {
constructor(message) {
super(message)
this.name = "NumberParserError"
}
}
class ComplexNumber {
constructor(realPart=0, imaginaryPart=0) {
this.realPart = realPart
this.imaginaryPart = imaginaryPart
}
isNumberNearlyZero(n) {
return Math.abs(n) < 1e-8
}
toArray() {
return [this.realPart, this.imaginaryPart]
}
static fromArray(arr) {
return new ComplexNumber(arr[0], arr[1])
}
static Zero() {
return new ComplexNumber(0, 0)
}
static One() {
return new ComplexNumber(1, 0)
}
static i() {
return new ComplexNumber(0, 1)
}
toString() {
if (this.realPart == 0 && this.imaginaryPart == 0) {
return "0"
}
let imaginaryString = ""
if (this.imaginaryPart == 1) {
imaginaryString = `+i`
} else if (this.imaginaryPart == -1) {
imaginaryString = "-i"
} else if (this.imaginaryPart > 0 && !this.isNumberNearlyZero(this.imaginaryPart)) {
imaginaryString = `+${this.imaginaryPart}i`
} else if (this.imaginaryPart < 0 && !this.isNumberNearlyZero(this.imaginaryPart)) {
imaginaryString = `-${-this.imaginaryPart}i`
}
if (this.isNumberNearlyZero(this.realPart)) {
if (imaginaryString.startsWith("+")) {
return imaginaryString.slice(1)
} else {
return imaginaryString
}
} else {
return `${this.realPart}${imaginaryString}`
}
}
static asComplexNumber(number) {
if (typeof number === "number") {
return new ComplexNumber(number, 0)
} else if (number instanceof ComplexNumber) {
return number
} else {
throw new Error("Failed to convert number to complex number type")
}
}
conjugate() {
return new ComplexNumber(this.realPart, -this.imaginaryPart)
}
get isReal() {
return this.isNumberNearlyZero(this.imaginaryPart)
}
magnitude() {
return Math.hypot(this.realPart, this.imaginaryPart)
}
magnitudeSquared() {
return this.realPart ** 2 + this.imaginaryPart ** 2
}
add(other) {
other = ComplexNumber.asComplexNumber(other)
return new ComplexNumber(this.realPart + other.realPart, this.imaginaryPart + other.imaginaryPart)
}
mul(other) {
other = ComplexNumber.asComplexNumber(other)
return new ComplexNumber(
this.realPart * other.realPart - this.imaginaryPart * other.imaginaryPart,
this.realPart * other.imaginaryPart + this.imaginaryPart * other.realPart
)
}
sub(other) {
other = ComplexNumber.asComplexNumber(other)
return new ComplexNumber(this.realPart - other.realPart, this.imaginaryPart - other.imaginaryPart)
}
div(other) {
other = ComplexNumber.asComplexNumber(other)
const otherSquaredMagnitude = other.magnitudeSquared()
if (otherSquaredMagnitude == 0) {
throw new Error("Zero Divison Error")
}
return new ComplexNumber(
(this.realPart * other.realPart + this.imaginaryPart * other.imaginaryPart) / otherSquaredMagnitude,
(this.imaginaryPart * other.realPart - this.realPart * other.imaginaryPart) / otherSquaredMagnitude
)
}
pow(other) {
other = ComplexNumber.asComplexNumber(other)
const [a, b] = this.toArray()
const [c, d] = other.toArray()
const r2 = this.magnitudeSquared()
if (r2 === 0) throw new NumberParserError("Base 0+0i is not defined for complex powers.")
const theta = Math.atan2(b, a)
const mag   = Math.pow(r2, c / 2) * Math.exp(-d * theta)
const ang   = c * theta + (d / 2) * Math.log(r2)
return new ComplexNumber(
mag * Math.cos(ang),
mag * Math.sin(ang),
)
}
sqrt() {
const a = this.realPart;
const b = this.imaginaryPart;
if (a == 0 && b == 0) return new ComplexNumber(0, 0)
const r = Math.hypot(a, b); // |z|
let u, v
if (a >= 0) {
u = Math.sqrt(0.5 * (r + a))
v = b / (2 * u)
} else {
v = Math.sqrt(0.5 * (r - a))
const s = (b >= 0 ? 1 : -1)
u = s * (b / (2 * v))
}
return new ComplexNumber(u, v)
}
abs() {
return new ComplexNumber(this.magnitude(), 0)
}
arg() {
return Math.atan2(this.imaginaryPart, this.realPart)
}
exp() {
const ea = Math.exp(this.realPart)
return new ComplexNumber(
ea * Math.cos(this.imaginaryPart),
ea * Math.sin(this.imaginaryPart)
)
}
ln() {
const r2 = this.magnitudeSquared()
if (r2 === 0) throw new NumberParserError("Ln(0) undefined")
return new ComplexNumber(0.5 * Math.log(r2), this.arg())
}
sin()  { const [a,b]=this.toArray(); return new ComplexNumber(Math.sin(a)*Math.cosh(b),  Math.cos(a)*Math.sinh(b)) }
cos()  { const [a,b]=this.toArray(); return new ComplexNumber(Math.cos(a)*Math.cosh(b), -Math.sin(a)*Math.sinh(b)) }
tan()  { return this.sin().div(this.cos()) }
sinh() { const [a,b]=this.toArray(); return new ComplexNumber(Math.sinh(a)*Math.cos(b),  Math.cosh(a)*Math.sin(b)) }
cosh() { const [a,b]=this.toArray(); return new ComplexNumber(Math.cosh(a)*Math.cos(b),  Math.sinh(a)*Math.sin(b)) }
tanh() { return this.sinh().div(this.cosh()) }
arcsin() {
const i = ComplexNumber.i()
return i.mul(-1).mul( i.mul(this).add( ComplexNumber.One().sub(this.mul(this)).sqrt() ).ln() )
}
arccos() {
const i = ComplexNumber.i()
return i.mul(-1).mul( this.add( this.sub(1).sqrt().mul(this.add(1).sqrt()) ).ln() )
}
arctan() {
const i = ComplexNumber.i()
return ComplexNumber.One().add(i.mul(this)).div(ComplexNumber.One().sub(i.mul(this))).ln().mul(i.mul(-0.5))
}
arcsinh() { return this.add( this.mul(this).add(1).sqrt() ).ln() }
arccosh() { return this.add( this.sub(1).sqrt().mul(this.add(1).sqrt()) ).ln() }
arctanh() { return ComplexNumber.One().add(this).div(ComplexNumber.One().sub(this)).ln().mul(0.5) }
log10() { return this.ln().div(Math.log(10)) }
log2()  { return this.ln().div(Math.log(2)) }
log3()  { return this.ln().div(Math.log(3)) }
static _lanczos() {
return [
0.99999999999980993,
676.5203681218851,
-1259.1392167224028,
771.3234287776531,
-176.6150291621406,
12.507343278686905,
-0.13857109526572012,
9.984369578019571e-6,
1.5056327351493116e-7
]
}
gamma() {
if (this.imaginaryPart === 0 && Number.isInteger(this.realPart) && this.realPart <= 0) {
throw new NumberParserError("Gamma pole at nonpositive integer")
}
if (this.imaginaryPart === 0) {
return new ComplexNumber(ComplexNumber._gammaReal(this.realPart), 0)
}
if (this.realPart < 0.5) {
const pi = Math.PI;
const s = this.mul(pi).sin();                // sin(πz)
const gm = ComplexNumber.One().sub(this).gamma(); // Γ(1 - z)
return new ComplexNumber(pi, 0).div(s.mul(gm));   // π / (sin(πz) Γ(1-z))
}
const p = ComplexNumber._lanczos(), g = 7;
const z1 = this.sub(1);                        // z - 1
let a = new ComplexNumber(p[0], 0);
for (let i = 1; i < p.length; i++) a = a.add(new ComplexNumber(p[i], 0).div(z1.add(i)));
const t = z1.add(g + 0.5);
const pref = new ComplexNumber(Math.sqrt(2 * Math.PI), 0);
return pref.mul(t.pow(z1.add(0.5))).mul(t.mul(-1).exp()).mul(a);
}
static _gammaReal(x) {
const p = ComplexNumber._lanczos(), g = 7;
if (x < 0.5) return Math.PI / (Math.sin(Math.PI * x) * ComplexNumber._gammaReal(1 - x));
x -= 1;
let a = p[0];
for (let i = 1; i < p.length; i++) a += p[i] / (x + i);
const t = x + g + 0.5;
return Math.sqrt(2 * Math.PI) * Math.pow(t, x + 0.5) * Math.exp(-t) * a;
}
factorial() {
if (this.imaginaryPart === 0 && Number.isInteger(this.realPart)) {
const n = this.realPart;
if (n < 0) throw new NumberParserError("Factorial undefined for negative integers");
let acc = 1;
for (let k = 2; k <= n; k++) acc *= k;      // fast exact product (to 170!)
return new ComplexNumber(acc, 0);
}
return this.add(1).gamma();
}
}
function evaluateNumberString(numberString) {
const constants = {
"pi": new ComplexNumber(Math.PI),
"π": new ComplexNumber(Math.PI),
"tau": new ComplexNumber(2 * Math.PI),
"phi": new ComplexNumber((1 + Math.sqrt(5)) / 2),
"Φ": new ComplexNumber((1 + Math.sqrt(5)) / 2),
"goldenratio": new ComplexNumber((1 + Math.sqrt(5)) / 2),
"e": new ComplexNumber(Math.E),
"i": new ComplexNumber(0, 1)
}
for (const [constant, value] of Object.entries(constants)) {
if (numberString == constant) {
return value
}
}
if (numberString.startsWith("-")) {
return evaluateNumberString("0" + numberString)
}
if (numberString == "inf") {
throw new NumberParserError(`Infinity is not a number`)
}
const imaginaryRegex = /^[0123456789]+(\.[0123456789]+)?i$/
const decimalRegex = /^[0123456789]+\.[0123456789]+$/
const intRegex = /^[0123456789]+$/
const hexDecimalRegex = /^0x[0123456789abcdef]+\.[0123456789abcdef]+$/
const hexIntRegex = /^0x[0123456789abcdef]+$/
const binDecimalRegex = /^0b[01]+\.[01]+$/
const binIntRegex = /^0b[01]+$/
const scientificRegex = /^\-?[0123456789]+(\.[0123456789]+)?e-?[0123456789]+$/
const allowedFunctions = {
"sqrt":    {compute: n => ComplexNumber.asComplexNumber(n).sqrt()},
"abs":     {compute: n => ComplexNumber.asComplexNumber(n).abs()},
"sin":     {compute: n => ComplexNumber.asComplexNumber(n).sin()},
"cos":     {compute: n => ComplexNumber.asComplexNumber(n).cos()},
"tan":     {compute: n => ComplexNumber.asComplexNumber(n).tan()},
"arcsin":  {compute: n => ComplexNumber.asComplexNumber(n).arcsin()},
"arccos":  {compute: n => ComplexNumber.asComplexNumber(n).arccos()},
"arctan":  {compute: n => ComplexNumber.asComplexNumber(n).arctan()},
"sinh":    {compute: n => ComplexNumber.asComplexNumber(n).sinh()},
"cosh":    {compute: n => ComplexNumber.asComplexNumber(n).cosh()},
"tanh":    {compute: n => ComplexNumber.asComplexNumber(n).tanh()},
"arcsinh": {compute: n => ComplexNumber.asComplexNumber(n).arcsinh()},
"arccosh": {compute: n => ComplexNumber.asComplexNumber(n).arccosh()},
"arctanh": {compute: n => ComplexNumber.asComplexNumber(n).arctanh()},
"log":     {compute: n => ComplexNumber.asComplexNumber(n).ln()},
"ln":      {compute: n => ComplexNumber.asComplexNumber(n).ln()},
"log10":   {compute: n => ComplexNumber.asComplexNumber(n).log10()},
"log2":    {compute: n => ComplexNumber.asComplexNumber(n).log2()},
"log3":    {compute: n => ComplexNumber.asComplexNumber(n).log3()},
"factorial": {compute: n => ComplexNumber.asComplexNumber(n).factorial()},
"gamma":  {compute: n => ComplexNumber.asComplexNumber(n).gamma()},
"Γ":       {compute: n => ComplexNumber.asComplexNumber(n).gamma()},
"exp":     {compute: n => ComplexNumber.asComplexNumber(n).exp()},
"":        {compute: n => ComplexNumber.asComplexNumber(n)},
}
for (const [functionStr, func] of Object.entries(allowedFunctions)) {
if (numberString.startsWith(`${functionStr}(`)) {
const numberPart = numberString.slice(functionStr.length + 1, -1)
let openCount = 0
let abortThisExecution = false
for (const char of numberPart) {
if (char == "(") {
openCount++
} else if (char == ")") {
openCount--
}
if (openCount < 0) {
abortThisExecution = true
break
}
}
if (abortThisExecution) {
continue
}
const value = evaluateNumberString(numberPart)
for (const constraint of (func.constraints ?? [])) {
if (constraint.if(value)) {
throw constraint.err()
}
}
return func.compute(value)
}
}
if (intRegex.test(numberString)) {
return new ComplexNumber(parseInt(numberString))
} else if (hexIntRegex.test(numberString)) {
return new ComplexNumber(parseInt(numberString.slice(2), 16))
} else if (binIntRegex.test(numberString)) {
return new ComplexNumber(parseInt(numberString.slice(2), 2))
}
if (imaginaryRegex.test(numberString)) {
return new ComplexNumber(0, parseFloat(numberString.slice(0, -1)))
} else if (decimalRegex.test(numberString)) {
return new ComplexNumber(parseFloat(numberString))
} else if (binDecimalRegex.test(numberString)) {
const [before, after] = numberString.split(".")
const beforeVal = parseInt(before.slice(2), 2)
const afterVal = parseInt(after, 2)
return new ComplexNumber(beforeVal + afterVal / (2 ** after.length))
} else if (hexDecimalRegex.test(numberString)) {
const [before, after] = numberString.split(".")
const beforeVal = parseInt(before.slice(2), 16)
const afterVal = parseInt(after, 16)
return new ComplexNumber(beforeVal + afterVal / (16 ** after.length))
}
if (scientificRegex.test(numberString)) {
let [decimal, exponent] = numberString.split("e")
decimal = parseFloat(decimal)
exponent = parseInt(exponent)
return new ComplexNumber(decimal * (10 ** exponent))
}
const operators = [
["+", (a, b) => a.add(b)],
["-", (a, b) => a.sub(b)],
["*", (a, b) => a.mul(b)],
["/", (a, b) => a.div(b)],
["^", (a, b) => a.pow(b)],
]
for (const [operatorName, operatorFunc] of operators) {
let currLevel = 0
let foundSplitIndex = null
for (let i = 0; i < numberString.length; i++) {
const char = numberString[i]
if (char == "(") currLevel++
if (char == ")") currLevel--
if (currLevel < 0) {
throw new NumberParserError(`Unbalanced parentheses`)
}
if (char == operatorName && currLevel == 0) {
foundSplitIndex = i
}
}
if (currLevel != 0) {
throw new NumberParserError(`Unbalanced parentheses`)
}
if (foundSplitIndex === null) {
continue
}
const parts = [
numberString.slice(0, foundSplitIndex),
numberString.slice(foundSplitIndex + 1)
]
for (let i = 0; i < 2; i++) {
parts[i] = evaluateNumberString(parts[i])
}
if (parts[1] == 0 && operatorName == "/") {
throw new NumberParserError(`Can't divide by zero`)
}
return operatorFunc(parts[0], parts[1])
}
if (numberString.startsWith("-")) {
return -evaluateNumberString(numberString.slice(1))
}
throw new NumberParserError(`Invalid number`)
}
class WurzleFunction {
constructor(termString) {
this.termString = termString
}
computeAt(x) {
const y = evaluateNumberString(this.termString.replaceAll("x", `(${x})`))
if (!y.isReal) {
throw new NumberParserError("Expected Real Number, got Complex")
} else {
return y.realPart
}
}
numericToStringResult(y) {
y = ComplexNumber.asComplexNumber(y).realPart
const maxPositiveNumber = 10 ** (NUM_CELLS_PER_ROW - 1) - 1
const maxNegativeNumber = -(10 ** (NUM_CELLS_PER_ROW - 2) - 1)
if (y > maxPositiveNumber) {
return ">" + maxPositiveNumber
} else if (y < maxNegativeNumber) {
return "<" + maxNegativeNumber
} else {
let yString = null
for (let n = 0; n <= NUM_CELLS_PER_ROW; n++) {
yString = (y >= 0 && y < 10) ? ("0" + y.toFixed(n)) : y.toFixed(n)
if (yString.length == NUM_CELLS_PER_ROW - 1) {
break
} else if (yString.length >= NUM_CELLS_PER_ROW) {
yString = yString.slice(0, NUM_CELLS_PER_ROW - 1)
}
}
if (parseFloat(yString) == y) {
return `=${yString}`
} else {
return `≈${yString}`
}
}
}
computeStringResultAt(x) {
let y = null
try {
y = this.computeAt(x)
} catch (e) {
if (e instanceof NumberParserError) {
if (e.message === "Expected Real Number, got Complex") {
return "unreal".slice(0, NUM_CELLS_PER_ROW).padStart(NUM_CELLS_PER_ROW, " ")
}
return "undefined".slice(0, NUM_CELLS_PER_ROW).padStart(NUM_CELLS_PER_ROW, " ")
} else {
throw e
}
}
return this.numericToStringResult(y)
}
}
class FunctionPlotter {
constructor(canvas, context, viewCentre, viewHeight) {
this.canvas = canvas
this.context = context ?? canvas.getContext("2d")
this.viewCentre = viewCentre ?? new Vector2d(0, 0)
this.viewHeight = viewHeight ?? 5
this.drawGridLines = false
this.wurzleFunctions = []
this.guessedPoints = []
}
removeAllFunctions() {
this.wurzleFunctions = []
}
get defaultForegroundColor() {
return getComputedStyle(document.body).getPropertyValue("--card-text-color")
}
get defaultBackgroundColor() {
return getComputedStyle(document.body).getPropertyValue("--header-button-background")
}
get viewWidth() {
return this.canvas.width / this.canvas.height * this.viewHeight
}
pointToScreenPos(point) {
const relativePoint = point.sub(this.viewCentre)
return new Vector2d(
(relativePoint.x / (this.viewWidth) + 0.5) * this.canvas.width,
(-relativePoint.y / (this.viewHeight) + 0.5) * this.canvas.height
)
}
screenPosToPoint(screenPos) {
const x = (screenPos.x / this.canvas.width - 0.5) * this.viewWidth
const y = -(screenPos.y / this.canvas.height - 0.5) * this.viewHeight
const relativePoint = new Vector2d(x, y)
return relativePoint.add(this.viewCentre)
}
clear() {
this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
}
drawPoint(point, {atScreenPos=false, radius=5, color="blue",
label=null, labelSize=13, labelColor=null, labelOffset=null,
labelBaseline="top", labelAlign="left"
}={}) {
labelColor ??= this.defaultForegroundColor
this.context.beginPath()
let screenPos = null
if (atScreenPos) {
screenPos = point
} else {
screenPos = this.pointToScreenPos(point)
}
this.context.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2)
this.context.fillStyle = color
this.context.fill()
if (label !== null) {
this.context.fillStyle = labelColor
this.context.textAlign = labelAlign
this.context.textBaseline = labelBaseline
this.context.font = `${labelSize}px monospace`
const labelPos = screenPos.addX(radius).addY(radius)
if (labelOffset !== null) {
labelPos.iadd(labelOffset.scale(labelSize))
}
this.context.fillText(label, screenPos.x + radius, screenPos.y + radius)
}
}
connectPoints(points, {atScreenPos=false, color=null, width=1}={}) {
color ??= this.defaultForegroundColor
this.context.strokeStyle = color
this.context.lineWidth = width
this.context.beginPath()
for (let i = 0; i < points.length; i++) {
const screenPos = atScreenPos ? points[i] : this.pointToScreenPos(points[i])
if (i == 0) {
this.context.moveTo(screenPos.x, screenPos.y)
} else {
this.context.lineTo(screenPos.x, screenPos.y)
}
}
this.context.stroke()
}
drawAxes() {
const minXY = this.screenPosToPoint(new Vector2d(0, this.canvas.height))
const maxXY = this.screenPosToPoint(new Vector2d(this.canvas.width, 0))
this.connectPoints([
new Vector2d(Math.floor(minXY.x) - 1, 0),
new Vector2d(Math.ceil(maxXY.x) + 1, 0)
])
this.connectPoints([
new Vector2d(0, Math.floor(minXY.y) - 1),
new Vector2d(0, Math.ceil(maxXY.y) + 1)
])
const pinStyling = {color: this.defaultForegroundColor, radius: 3}
let stepSize = 10 ** Math.ceil(Math.log10(Math.max(
Math.ceil(maxXY.x) - Math.floor(minXY.x),
Math.ceil(maxXY.y) - Math.floor(minXY.y)
)) + 1)
let numTicksVisible = Math.max(
Math.ceil(maxXY.x) - Math.floor(minXY.x),
Math.ceil(maxXY.y) - Math.floor(minXY.y)
) / stepSize
let i = 0
while (numTicksVisible < 8) {
const factor = (i % 2 == 0) ? 2 : 5
stepSize /= factor
numTicksVisible *= factor
i++
}
let startX = Math.floor(minXY.x)
startX -= startX % stepSize
for (let x = startX; x <= Math.ceil(maxXY.x); x += stepSize) {
if (x == 0) continue
this.drawPoint(new Vector2d(x, 0), {label: Math.round(x * 10) / 10, ...pinStyling})
}
let startY = Math.floor(minXY.y)
startY -= startY % stepSize
for (let y = startY; y <= Math.ceil(maxXY.y); y += stepSize) {
this.drawPoint(new Vector2d(0, y), {label: Math.round(y * 10) / 10, ...pinStyling})
}
if (!this.drawGridLines) {
return
}
for (let x = startX; x <= Math.ceil(maxXY.x); x += stepSize) {
if (x == 0) continue
this.connectPoints([
new Vector2d(x, Math.floor(minXY.y)),
new Vector2d(x, Math.ceil(maxXY.y))
], {color: this.defaultForegroundColor, width: 0.5})
}
for (let y = startY; y <= Math.ceil(maxXY.y); y += stepSize) {
this.connectPoints([
new Vector2d(Math.floor(minXY.x), y),
new Vector2d(Math.ceil(maxXY.x), y)
], {color: this.defaultForegroundColor, width: 0.5})
}
}
plot(wurzleFunction, color="blue", width=1) {
const points = Array.from({length: this.canvas.width})
.map((_, i) => this.screenPosToPoint(new Vector2d(i, 0)).x)
.map(x => {
try {
const y = wurzleFunction.computeAt(x)
if (isNaN(y)) {
throw new Error("Value may not be NaN")
}
return new Vector2d(x, y)
} catch {
return null
}
})
const maxDelta = 10
const sign = x => x > 0 ? 1 : x < 0 ? -1 : 0
let drewAtLeastOnePoint = false
for (let i = 1; i < points.length; i++) {
const [p1, p2] = [points[i - 1], points[i]]
if (p1 === null || p2 === null) {
continue
}
if (p1.distance(p2) < maxDelta || sign(p1.y) == sign(p2.y)) {
this.connectPoints([p1, p2], {color, width})
drewAtLeastOnePoint = true
}
}
return drewAtLeastOnePoint
}
addFunction(wurzleFunction) {
this.wurzleFunctions.push(wurzleFunction)
}
removeFunction(wurzleFunction) {
this.wurzleFunctions = this.wurzleFunctions.filter(f => f.termString != wurzleFunction.termString)
}
makeInteractive() {
const redraw = () => {
this.canvas.width = this.canvas.clientWidth
this.canvas.height = this.canvas.clientHeight
this.clear()
this.drawAxes()
let drewAtLeastOnePoint = false
for (const func of this.wurzleFunctions) {
if (this.plot(func)) {
drewAtLeastOnePoint = true
}
}
for (let i = 0; i < this.guessedPoints.length; i++) {
this.drawPoint(this.guessedPoints[i])
}
return drewAtLeastOnePoint
}
this.canvas.addEventListener("wheel", event => {
this.viewHeight *= event.deltaY / 1000 + 1
this.viewHeight = Math.max(this.viewHeight, 0.1)
event.preventDefault()
redraw()
})
let dragPoint = null
let dragStartViewCentre = null
const mousedown = event => {
dragPoint = this.screenPosToPoint(Vector2d.fromEvent(event, this.canvas))
dragStartViewCentre = this.viewCentre.copy()
}
const mousemove = event => {
if (!dragPoint) {
return
}
let temp = this.viewCentre.copy()
this.viewCentre = dragStartViewCentre
const delta = this.screenPosToPoint(Vector2d.fromEvent(event, this.canvas)).sub(dragPoint)
this.viewCentre = temp.copy()
event.preventDefault()
this.viewCentre = dragStartViewCentre.sub(delta)
redraw()
}
const mouseup = event => {
dragPoint = null
dragStartViewCentre = null
}
this.canvas.addEventListener("mousedown", mousedown)
this.canvas.addEventListener("mousemove", mousemove)
this.canvas.addEventListener("mouseup", mouseup)
this.canvas.addEventListener("touchstart", mousedown)
this.canvas.addEventListener("touchmove", mousemove)
this.canvas.addEventListener("touchend", mouseup)
window.addEventListener("resize", redraw)
redraw()
return {redraw}
}
}
const urlParams = new URLSearchParams(window.location.search)
class PersonalityTest {
constructor(questions) {
this.questions = questions.map(q => {
q.answerIndex = urlParams.has("r") ? Math.floor(Math.random() * NUM_BUTTONS_PER_QUESTION) : null
return q
})
shuffle(this.questions)
}
initHtml() {
this.questionContainers = []
questionsContainer.innerHTML = ""
let nextQuestionIndex = 0
for (const question of this.questions) {
nextQuestionIndex++
const questionContainer = document.createElement("div")
questionContainer.classList.add("question-container")
const questionHeader = document.createElement("div")
questionHeader.classList.add("question-header")
for (const [langKey, langValue] of Object.entries(question.statement)) {
const questionHeaderText = document.createElement("div")
questionHeaderText.classList.add("question-header-text")
questionHeaderText.textContent = `(${nextQuestionIndex}/${this.questions.length}) ${langValue}`
questionHeaderText.setAttribute("lang", langKey)
questionHeader.appendChild(questionHeaderText)
}
const questionBody = document.createElement("div")
questionBody.classList.add("question-body")
const questionButtonsContainer = document.createElement("div")
questionButtonsContainer.classList.add("question-buttons-container")
const allQuestionButtons = []
const updateButtons = () => {
for (let i = 0; i < NUM_BUTTONS_PER_QUESTION; i++) {
const button = allQuestionButtons[i]
if (i === question.answerIndex) {
button.classList.add("selected")
button.classList.remove("noanswer")
} else {
button.classList.remove("selected")
button.classList.remove("noanswer")
}
if (question.answerIndex === null) {
button.classList.add("noanswer")
button.classList.remove("selected")
}
}
if (question.answerIndex !== null) {
questionContainer.classList.add("answered")
} else {
questionContainer.classList.remove("answered")
}
}
for (let i = 0; i < NUM_BUTTONS_PER_QUESTION; i++) {
const questionButton = document.createElement("button")
questionButton.classList.add("question-button")
allQuestionButtons.push(questionButton)
questionButtonsContainer.appendChild(questionButton)
questionButton.addEventListener("click", () => {
if (showingResults) return
question.answerIndex = i
updateButtons()
const smallestUnselectedIndex = this.getUnfinishedQuestionIndex()
if (smallestUnselectedIndex !== null && this.questionContainers[smallestUnselectedIndex]) {
this.questionContainers[smallestUnselectedIndex].scrollIntoView({
behavior: "smooth",
block: "center"
})
} else if (smallestUnselectedIndex === null) {
finishQuestionsButton.scrollIntoView({
behavior: "smooth",
block: "center"
})
}
})
}
updateButtons()
const questionExplainContainer = document.createElement("div")
questionExplainContainer.classList.add("question-explain-container")
const questionAgree = document.createElement("div")
questionAgree.classList.add("agree")
const questionDisagree = document.createElement("div")
questionDisagree.classList.add("disagree")
questionExplainContainer.appendChild(questionAgree)
questionExplainContainer.appendChild(questionDisagree)
questionBody.appendChild(questionButtonsContainer)
questionBody.appendChild(questionExplainContainer)
questionContainer.appendChild(questionHeader)
questionContainer.appendChild(questionBody)
questionsContainer.appendChild(questionContainer)
this.questionContainers.push(questionContainer)
}
}
computeResults() {
const result = Object.fromEntries(Array.from(Object.keys(TestResultCategories)).map(key => [key, 0]))
const halfNumButtons = Math.floor(NUM_BUTTONS_PER_QUESTION / 2)
for (const question of this.questions) {
if (question.answerIndex === null) continue
const agreement = (halfNumButtons - question.answerIndex) / halfNumButtons
const agreementFactor = (agreement + 1) / 2
const effectKeys = Object.keys(question.effect.agree)
for (const key of effectKeys) {
const agreeEffect = question.effect.agree[key] || 0
const disagreeEffect = question.effect.disagree[key] || 0
const interpolatedEffect = agreeEffect * agreementFactor + disagreeEffect * (1 - agreementFactor)
result[key] += interpolatedEffect
}
}
const sigmoid = x => 2 / (1 + Math.exp(-x)) - 1
for (const key of Object.keys(result)) {
result[key] = sigmoid(result[key])
result[key] = Math.round(result[key] * 100) / 100 // round to 2 decimal places
}
return result
}
computePersonality() {
const result = this.computeResults()
let personality = {}
let bestDistance = Infinity
for (const testResult of TestResults) {
const distance = Object.keys(result).reduce((sum, key) => {
return sum + Math.pow(result[key] - testResult.location[key], 2)
}, 0)
if (distance < bestDistance) {
bestDistance = distance
personality = testResult
}
}
return personality
}
computePersonalityScores() {
const result = this.computeResults()
const maxDistance = 2 * Math.sqrt(Object.keys(result).length)
const results = TestResults.map(testResult => {
const distance = Math.sqrt(Object.keys(result).reduce((sum, key) => {
return sum + Math.pow(result[key] - testResult.location[key], 2)
}, 0))
return {
name: testResult.termString,
distance: distance
}
})
results.sort((a, b) => a.distance - b.distance)
const scores = results.map(result => {
return {
name: result.name,
score: Math.round(((1 - result.distance / maxDistance) ** 2) * 10000) / 100
}
})
return scores
}
getUnfinishedQuestionIndex() {
for (let i = 0; i < this.questions.length; i++) {
if (this.questions[i].answerIndex === null) {
return i
}
}
return null
}
}
async function generateShareImage(termString, {imageSize=new Vector2d(600, 600)}={}) {
const canvas = document.createElement("canvas")
const context = canvas.getContext("2d")
canvas.width = imageSize.x
canvas.height = imageSize.y
const f = new WurzleFunction(termString)
const plotter = new FunctionPlotter(canvas, context)
plotter.viewCentre = new Vector2d(0, 0)
plotter.viewHeight = Math.PI * 3
plotter.drawGridLines = true
plotter.clear()
context.fillStyle = "white"
context.fillRect(0, 0, canvas.width, canvas.height)
plotter.drawAxes()
plotter.plot(f, "blue", 5)
const headerFont = getComputedStyle(document.body).getPropertyValue("--header-font").trim()
function drawCardWithText(text, position, {fontSize=50, padding=20, color="black"}={}) {
context.font = `${fontSize}px ${headerFont}`
context.textAlign = "center"
context.textBaseline = "middle"
context.fillStyle = "white"
const textDimensions = context.measureText(text)
context.globalAlpha = 0.9
context.fillRect(
position.x - textDimensions.width / 2 - padding,
position.y - fontSize / 2 - padding,
textDimensions.width + padding * 2,
fontSize + padding * 2
)
context.globalAlpha = 1
context.fillStyle = color
context.fillText(text, position.x, position.y)
}
const lines = [
`f(x) = ${termString}`,
"recmaths.ch/games/personality-test",
]
drawCardWithText(lines[1], new Vector2d(canvas.width / 2, canvas.height * 0.9), {fontSize: 30})
drawCardWithText(lines[0], new Vector2d(canvas.width / 2, canvas.height * 0.8), {fontSize: 50, color: "blue"})
return new Promise((resolve) => {
canvas.toBlob(blob => {
if (blob) {
resolve(blob)
} else {
console.error("Failed to create blob from canvas")
resolve(null)
}
}, "image/png")
})
}
const test = new PersonalityTest(TestQuestions)
test.initHtml()
let showingResults = false
finishQuestionsButton.addEventListener("click", () => {
const unfinishedQuestionIndex = test.getUnfinishedQuestionIndex()
if (unfinishedQuestionIndex !== null) {
test.questionContainers[unfinishedQuestionIndex].scrollIntoView({ behavior: "smooth", block: "center" })
return
}
showingResults = true
resultsContainer.style.display = "block"
const personality = test.computePersonality()
resultFunction.textContent = `f(x) = ${personality.termString}`
for (const [langKey, langValue] of Object.entries(personality.description)) {
const resultDescriptionText = document.createElement("div")
resultDescriptionText.classList.add("result-description-text")
resultDescriptionText.textContent = langValue
resultDescriptionText.setAttribute("lang", langKey)
resultDescription.appendChild(resultDescriptionText)
}
setTimeout(() => {
shareResultsButton.scrollIntoView({ behavior: "smooth", block: "end" })
}, 100)
finishQuestionsButton.remove()
const f = new WurzleFunction(personality.termString)
const plotter = new FunctionPlotter(resultFunctionCanvas, resultFunctionContext)
plotter.viewCentre = new Vector2d(0, 0)
plotter.viewHeight = 8.5
plotter.addFunction(f)
plotter.makeInteractive()
const personalityScores = test.computePersonalityScores()
for (const {name, score} of personalityScores) {
const row = document.createElement("tr")
const nameCell = document.createElement("td")
nameCell.textContent = name
const scoreCell = document.createElement("td")
scoreCell.textContent = score.toFixed(2)
row.appendChild(nameCell)
row.appendChild(scoreCell)
resultsTableBody.appendChild(row)
}
})
async function shareResult() {
if (!showingResults) {
return
}
const personality = test.computePersonality()
const scores = test.computePersonalityScores()
const resultTerm = personality.termString
const resultScore = scores[0].score.toFixed(2)
let shareText = `📈 Personality Test 📉\nf(x) = ${resultTerm} (confidence=${resultScore}%)\nrecmaths.ch/games/personality-test`
if (document.documentElement.lang.startsWith("de")) {
shareText = `📈 Persönlichkeitstest 📉\nf(x) = ${resultTerm} (Sicherheit=${resultScore}%)\nrecmaths.ch/games/personality-test`
}
const fallBackShare = async () => {
await navigator.clipboard.writeText(shareText)
if (document.documentElement.lang.startsWith("de")) {
alert("Ergebnis in die Zwischenablage kopiert")
} else {
alert("Result copied to clipboard")
}
}
const imageBlob = await generateShareImage(resultTerm)
if (!imageBlob || !window.navigator.share) {
await fallBackShare()
return
}
const shareData = {
title: "Personality Test Result",
text: shareText,
files: [new File([imageBlob], "result.png", { type: "image/png" })]
}
try {
await navigator.share(shareData)
} catch (error) {
console.error("Error sharing result:", error)
await fallBackShare()
}
}
